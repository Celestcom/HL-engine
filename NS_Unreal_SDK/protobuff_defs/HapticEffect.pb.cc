// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HapticEffect.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "HapticEffect.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace NullSpaceHaptics {

namespace {

const ::google::protobuf::Descriptor* Effect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Effect_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sequence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sequence_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pattern_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pattern_reflection_ = NULL;
const ::google::protobuf::Descriptor* Experience_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Experience_reflection_ = NULL;
const ::google::protobuf::Descriptor* HapticFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HapticFile_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HapticFile_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RootEffect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RootEffect_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RootEffect_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PatternNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PatternNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExperienceNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExperienceNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* SequenceDefinitions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SequenceDefinitions_reflection_ = NULL;
const ::google::protobuf::Descriptor* PatternDefinitions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PatternDefinitions_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExperienceDefinitions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExperienceDefinitions_reflection_ = NULL;
const ::google::protobuf::Descriptor* HapticDescriptionFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HapticDescriptionFile_reflection_ = NULL;
const ::google::protobuf::Descriptor* HapticDescriptionFile_SequenceDefinitionsEntry_descriptor_ = NULL;
const ::google::protobuf::Descriptor* HapticDescriptionFile_PatternDefinitionsEntry_descriptor_ = NULL;
const ::google::protobuf::Descriptor* HapticDescriptionFile_ExperienceDefinitionsEntry_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_HapticEffect_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_HapticEffect_2eproto() {
  protobuf_AddDesc_HapticEffect_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "HapticEffect.proto");
  GOOGLE_CHECK(file != NULL);
  Effect_descriptor_ = file->message_type(0);
  static const int Effect_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Effect, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Effect, effect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Effect, strength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Effect, duration_),
  };
  Effect_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Effect_descriptor_,
      Effect::default_instance_,
      Effect_offsets_,
      -1,
      -1,
      -1,
      sizeof(Effect),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Effect, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Effect, _is_default_instance_));
  Sequence_descriptor_ = file->message_type(1);
  static const int Sequence_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, effects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, strength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, area_),
  };
  Sequence_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Sequence_descriptor_,
      Sequence::default_instance_,
      Sequence_offsets_,
      -1,
      -1,
      -1,
      sizeof(Sequence),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, _is_default_instance_));
  Pattern_descriptor_ = file->message_type(2);
  static const int Pattern_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pattern, sequences_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pattern, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pattern, strength_),
  };
  Pattern_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Pattern_descriptor_,
      Pattern::default_instance_,
      Pattern_offsets_,
      -1,
      -1,
      -1,
      sizeof(Pattern),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pattern, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pattern, _is_default_instance_));
  Experience_descriptor_ = file->message_type(3);
  static const int Experience_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Experience, patterns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Experience, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Experience, strength_),
  };
  Experience_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Experience_descriptor_,
      Experience::default_instance_,
      Experience_offsets_,
      -1,
      -1,
      -1,
      sizeof(Experience),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Experience, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Experience, _is_default_instance_));
  HapticFile_descriptor_ = file->message_type(4);
  static const int HapticFile_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticFile, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticFile, sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticFile, pattern_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticFile, experience_),
  };
  HapticFile_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HapticFile_descriptor_,
      HapticFile::default_instance_,
      HapticFile_offsets_,
      -1,
      -1,
      -1,
      sizeof(HapticFile),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticFile, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticFile, _is_default_instance_));
  HapticFile_Type_descriptor_ = HapticFile_descriptor_->enum_type(0);
  RootEffect_descriptor_ = file->message_type(5);
  static const int RootEffect_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RootEffect, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RootEffect, type_),
  };
  RootEffect_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RootEffect_descriptor_,
      RootEffect::default_instance_,
      RootEffect_offsets_,
      -1,
      -1,
      -1,
      sizeof(RootEffect),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RootEffect, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RootEffect, _is_default_instance_));
  RootEffect_Type_descriptor_ = RootEffect_descriptor_->enum_type(0);
  PatternNode_descriptor_ = file->message_type(6);
  static const int PatternNode_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternNode, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternNode, sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternNode, area_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternNode, strength_),
  };
  PatternNode_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PatternNode_descriptor_,
      PatternNode::default_instance_,
      PatternNode_offsets_,
      -1,
      -1,
      -1,
      sizeof(PatternNode),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternNode, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternNode, _is_default_instance_));
  ExperienceNode_descriptor_ = file->message_type(7);
  static const int ExperienceNode_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceNode, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceNode, pattern_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceNode, strength_),
  };
  ExperienceNode_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ExperienceNode_descriptor_,
      ExperienceNode::default_instance_,
      ExperienceNode_offsets_,
      -1,
      -1,
      -1,
      sizeof(ExperienceNode),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceNode, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceNode, _is_default_instance_));
  SequenceDefinitions_descriptor_ = file->message_type(8);
  static const int SequenceDefinitions_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceDefinitions, effects_),
  };
  SequenceDefinitions_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SequenceDefinitions_descriptor_,
      SequenceDefinitions::default_instance_,
      SequenceDefinitions_offsets_,
      -1,
      -1,
      -1,
      sizeof(SequenceDefinitions),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceDefinitions, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceDefinitions, _is_default_instance_));
  PatternDefinitions_descriptor_ = file->message_type(9);
  static const int PatternDefinitions_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternDefinitions, pattern_nodes_),
  };
  PatternDefinitions_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PatternDefinitions_descriptor_,
      PatternDefinitions::default_instance_,
      PatternDefinitions_offsets_,
      -1,
      -1,
      -1,
      sizeof(PatternDefinitions),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternDefinitions, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PatternDefinitions, _is_default_instance_));
  ExperienceDefinitions_descriptor_ = file->message_type(10);
  static const int ExperienceDefinitions_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceDefinitions, experience_nodes_),
  };
  ExperienceDefinitions_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ExperienceDefinitions_descriptor_,
      ExperienceDefinitions::default_instance_,
      ExperienceDefinitions_offsets_,
      -1,
      -1,
      -1,
      sizeof(ExperienceDefinitions),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceDefinitions, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExperienceDefinitions, _is_default_instance_));
  HapticDescriptionFile_descriptor_ = file->message_type(11);
  static const int HapticDescriptionFile_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticDescriptionFile, effect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticDescriptionFile, sequence_definitions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticDescriptionFile, pattern_definitions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticDescriptionFile, experience_definitions_),
  };
  HapticDescriptionFile_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HapticDescriptionFile_descriptor_,
      HapticDescriptionFile::default_instance_,
      HapticDescriptionFile_offsets_,
      -1,
      -1,
      -1,
      sizeof(HapticDescriptionFile),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticDescriptionFile, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HapticDescriptionFile, _is_default_instance_));
  HapticDescriptionFile_SequenceDefinitionsEntry_descriptor_ = HapticDescriptionFile_descriptor_->nested_type(0);
  HapticDescriptionFile_PatternDefinitionsEntry_descriptor_ = HapticDescriptionFile_descriptor_->nested_type(1);
  HapticDescriptionFile_ExperienceDefinitionsEntry_descriptor_ = HapticDescriptionFile_descriptor_->nested_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_HapticEffect_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Effect_descriptor_, &Effect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Sequence_descriptor_, &Sequence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Pattern_descriptor_, &Pattern::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Experience_descriptor_, &Experience::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HapticFile_descriptor_, &HapticFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RootEffect_descriptor_, &RootEffect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PatternNode_descriptor_, &PatternNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ExperienceNode_descriptor_, &ExperienceNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SequenceDefinitions_descriptor_, &SequenceDefinitions::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PatternDefinitions_descriptor_, &PatternDefinitions::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ExperienceDefinitions_descriptor_, &ExperienceDefinitions::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HapticDescriptionFile_descriptor_, &HapticDescriptionFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
        HapticDescriptionFile_SequenceDefinitionsEntry_descriptor_,
        ::google::protobuf::internal::MapEntry<
            ::std::string,
            ::NullSpaceHaptics::SequenceDefinitions,
            ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
            ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
            0>::CreateDefaultInstance(
                HapticDescriptionFile_SequenceDefinitionsEntry_descriptor_));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
        HapticDescriptionFile_PatternDefinitionsEntry_descriptor_,
        ::google::protobuf::internal::MapEntry<
            ::std::string,
            ::NullSpaceHaptics::PatternDefinitions,
            ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
            ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
            0>::CreateDefaultInstance(
                HapticDescriptionFile_PatternDefinitionsEntry_descriptor_));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
        HapticDescriptionFile_ExperienceDefinitionsEntry_descriptor_,
        ::google::protobuf::internal::MapEntry<
            ::std::string,
            ::NullSpaceHaptics::ExperienceDefinitions,
            ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
            ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
            0>::CreateDefaultInstance(
                HapticDescriptionFile_ExperienceDefinitionsEntry_descriptor_));
}

}  // namespace

void protobuf_ShutdownFile_HapticEffect_2eproto() {
  delete Effect::default_instance_;
  delete Effect_reflection_;
  delete Sequence::default_instance_;
  delete Sequence_reflection_;
  delete Pattern::default_instance_;
  delete Pattern_reflection_;
  delete Experience::default_instance_;
  delete Experience_reflection_;
  delete HapticFile::default_instance_;
  delete HapticFile_reflection_;
  delete RootEffect::default_instance_;
  delete RootEffect_reflection_;
  delete PatternNode::default_instance_;
  delete PatternNode_reflection_;
  delete ExperienceNode::default_instance_;
  delete ExperienceNode_reflection_;
  delete SequenceDefinitions::default_instance_;
  delete SequenceDefinitions_reflection_;
  delete PatternDefinitions::default_instance_;
  delete PatternDefinitions_reflection_;
  delete ExperienceDefinitions::default_instance_;
  delete ExperienceDefinitions_reflection_;
  delete HapticDescriptionFile::default_instance_;
  delete HapticDescriptionFile_reflection_;
}

void protobuf_AddDesc_HapticEffect_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_HapticEffect_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\022HapticEffect.proto\022\020NullSpaceHaptics\"J"
    "\n\006Effect\022\014\n\004time\030\001 \001(\002\022\016\n\006effect\030\002 \001(\t\022\020"
    "\n\010strength\030\003 \001(\002\022\020\n\010duration\030\004 \001(\002\"c\n\010Se"
    "quence\022)\n\007effects\030\001 \003(\0132\030.NullSpaceHapti"
    "cs.Effect\022\014\n\004time\030\002 \001(\002\022\020\n\010strength\030\003 \001("
    "\002\022\014\n\004area\030\004 \001(\r\"X\n\007Pattern\022-\n\tsequences\030"
    "\001 \003(\0132\032.NullSpaceHaptics.Sequence\022\014\n\004tim"
    "e\030\002 \001(\002\022\020\n\010strength\030\003 \001(\002\"Y\n\nExperience\022"
    "+\n\010patterns\030\001 \003(\0132\031.NullSpaceHaptics.Pat"
    "tern\022\014\n\004time\030\002 \001(\002\022\020\n\010strength\030\003 \001(\002\"\211\002\n"
    "\nHapticFile\022/\n\004type\030\001 \001(\0162!.NullSpaceHap"
    "tics.HapticFile.Type\022,\n\010sequence\030\002 \001(\0132\032"
    ".NullSpaceHaptics.Sequence\022*\n\007pattern\030\003 "
    "\001(\0132\031.NullSpaceHaptics.Pattern\0220\n\nexperi"
    "ence\030\004 \001(\0132\034.NullSpaceHaptics.Experience"
    "\">\n\004Type\022\013\n\007UNKNOWN\020\000\022\014\n\010SEQUENCE\020\001\022\013\n\007P"
    "ATTERN\020\002\022\016\n\nEXPERIENCE\020\003\"\213\001\n\nRootEffect\022"
    "\014\n\004name\030\001 \001(\t\022/\n\004type\030\002 \001(\0162!.NullSpaceH"
    "aptics.RootEffect.Type\">\n\004Type\022\013\n\007UNKNOW"
    "N\020\000\022\014\n\010SEQUENCE\020\001\022\013\n\007PATTERN\020\002\022\016\n\nEXPERI"
    "ENCE\020\003\"M\n\013PatternNode\022\014\n\004time\030\001 \001(\002\022\020\n\010s"
    "equence\030\002 \001(\t\022\014\n\004area\030\003 \001(\r\022\020\n\010strength\030"
    "\004 \001(\002\"A\n\016ExperienceNode\022\014\n\004time\030\001 \001(\002\022\017\n"
    "\007pattern\030\002 \001(\t\022\020\n\010strength\030\003 \001(\002\"@\n\023Sequ"
    "enceDefinitions\022)\n\007effects\030\001 \003(\0132\030.NullS"
    "paceHaptics.Effect\"J\n\022PatternDefinitions"
    "\0224\n\rpattern_nodes\030\001 \003(\0132\035.NullSpaceHapti"
    "cs.PatternNode\"S\n\025ExperienceDefinitions\022"
    ":\n\020experience_nodes\030\001 \003(\0132 .NullSpaceHap"
    "tics.ExperienceNode\"\222\005\n\025HapticDescriptio"
    "nFile\022,\n\006effect\030\001 \001(\0132\034.NullSpaceHaptics"
    ".RootEffect\022^\n\024sequence_definitions\030\002 \003("
    "\0132@.NullSpaceHaptics.HapticDescriptionFi"
    "le.SequenceDefinitionsEntry\022\\\n\023pattern_d"
    "efinitions\030\003 \003(\0132\?.NullSpaceHaptics.Hapt"
    "icDescriptionFile.PatternDefinitionsEntr"
    "y\022b\n\026experience_definitions\030\004 \003(\0132B.Null"
    "SpaceHaptics.HapticDescriptionFile.Exper"
    "ienceDefinitionsEntry\032a\n\030SequenceDefinit"
    "ionsEntry\022\013\n\003key\030\001 \001(\t\0224\n\005value\030\002 \001(\0132%."
    "NullSpaceHaptics.SequenceDefinitions:\0028\001"
    "\032_\n\027PatternDefinitionsEntry\022\013\n\003key\030\001 \001(\t"
    "\0223\n\005value\030\002 \001(\0132$.NullSpaceHaptics.Patte"
    "rnDefinitions:\0028\001\032e\n\032ExperienceDefinitio"
    "nsEntry\022\013\n\003key\030\001 \001(\t\0226\n\005value\030\002 \001(\0132\'.Nu"
    "llSpaceHaptics.ExperienceDefinitions:\0028\001"
    "b\006proto3", 1848);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "HapticEffect.proto", &protobuf_RegisterTypes);
  Effect::default_instance_ = new Effect();
  Sequence::default_instance_ = new Sequence();
  Pattern::default_instance_ = new Pattern();
  Experience::default_instance_ = new Experience();
  HapticFile::default_instance_ = new HapticFile();
  RootEffect::default_instance_ = new RootEffect();
  PatternNode::default_instance_ = new PatternNode();
  ExperienceNode::default_instance_ = new ExperienceNode();
  SequenceDefinitions::default_instance_ = new SequenceDefinitions();
  PatternDefinitions::default_instance_ = new PatternDefinitions();
  ExperienceDefinitions::default_instance_ = new ExperienceDefinitions();
  HapticDescriptionFile::default_instance_ = new HapticDescriptionFile();
  Effect::default_instance_->InitAsDefaultInstance();
  Sequence::default_instance_->InitAsDefaultInstance();
  Pattern::default_instance_->InitAsDefaultInstance();
  Experience::default_instance_->InitAsDefaultInstance();
  HapticFile::default_instance_->InitAsDefaultInstance();
  RootEffect::default_instance_->InitAsDefaultInstance();
  PatternNode::default_instance_->InitAsDefaultInstance();
  ExperienceNode::default_instance_->InitAsDefaultInstance();
  SequenceDefinitions::default_instance_->InitAsDefaultInstance();
  PatternDefinitions::default_instance_->InitAsDefaultInstance();
  ExperienceDefinitions::default_instance_->InitAsDefaultInstance();
  HapticDescriptionFile::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_HapticEffect_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_HapticEffect_2eproto {
  StaticDescriptorInitializer_HapticEffect_2eproto() {
    protobuf_AddDesc_HapticEffect_2eproto();
  }
} static_descriptor_initializer_HapticEffect_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Effect::kTimeFieldNumber;
const int Effect::kEffectFieldNumber;
const int Effect::kStrengthFieldNumber;
const int Effect::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Effect::Effect()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.Effect)
}

void Effect::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Effect::Effect(const Effect& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.Effect)
}

void Effect::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  time_ = 0;
  effect_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  strength_ = 0;
  duration_ = 0;
}

Effect::~Effect() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.Effect)
  SharedDtor();
}

void Effect::SharedDtor() {
  effect_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Effect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Effect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Effect_descriptor_;
}

const Effect& Effect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

Effect* Effect::default_instance_ = NULL;

Effect* Effect::New(::google::protobuf::Arena* arena) const {
  Effect* n = new Effect;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Effect::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.Effect)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Effect, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Effect*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(time_, duration_);
  effect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool Effect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.Effect)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_effect;
        break;
      }

      // optional string effect = 2;
      case 2: {
        if (tag == 18) {
         parse_effect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_effect()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->effect().data(), this->effect().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "NullSpaceHaptics.Effect.effect"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_strength;
        break;
      }

      // optional float strength = 3;
      case 3: {
        if (tag == 29) {
         parse_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &strength_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_duration;
        break;
      }

      // optional float duration = 4;
      case 4: {
        if (tag == 37) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &duration_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.Effect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.Effect)
  return false;
#undef DO_
}

void Effect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.Effect)
  // optional float time = 1;
  if (this->time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }

  // optional string effect = 2;
  if (this->effect().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->effect().data(), this->effect().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.Effect.effect");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->effect(), output);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->strength(), output);
  }

  // optional float duration = 4;
  if (this->duration() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->duration(), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.Effect)
}

::google::protobuf::uint8* Effect::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.Effect)
  // optional float time = 1;
  if (this->time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->time(), target);
  }

  // optional string effect = 2;
  if (this->effect().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->effect().data(), this->effect().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.Effect.effect");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->effect(), target);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->strength(), target);
  }

  // optional float duration = 4;
  if (this->duration() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->duration(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.Effect)
  return target;
}

int Effect::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.Effect)
  int total_size = 0;

  // optional float time = 1;
  if (this->time() != 0) {
    total_size += 1 + 4;
  }

  // optional string effect = 2;
  if (this->effect().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->effect());
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    total_size += 1 + 4;
  }

  // optional float duration = 4;
  if (this->duration() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Effect::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.Effect)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Effect* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Effect>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.Effect)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.Effect)
    MergeFrom(*source);
  }
}

void Effect::MergeFrom(const Effect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.Effect)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.time() != 0) {
    set_time(from.time());
  }
  if (from.effect().size() > 0) {

    effect_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.effect_);
  }
  if (from.strength() != 0) {
    set_strength(from.strength());
  }
  if (from.duration() != 0) {
    set_duration(from.duration());
  }
}

void Effect::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.Effect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Effect::CopyFrom(const Effect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.Effect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Effect::IsInitialized() const {

  return true;
}

void Effect::Swap(Effect* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Effect::InternalSwap(Effect* other) {
  std::swap(time_, other->time_);
  effect_.Swap(&other->effect_);
  std::swap(strength_, other->strength_);
  std::swap(duration_, other->duration_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Effect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Effect_descriptor_;
  metadata.reflection = Effect_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Effect

// optional float time = 1;
void Effect::clear_time() {
  time_ = 0;
}
 float Effect::time() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Effect.time)
  return time_;
}
 void Effect::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Effect.time)
}

// optional string effect = 2;
void Effect::clear_effect() {
  effect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Effect::effect() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Effect.effect)
  return effect_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Effect::set_effect(const ::std::string& value) {
  
  effect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Effect.effect)
}
 void Effect::set_effect(const char* value) {
  
  effect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NullSpaceHaptics.Effect.effect)
}
 void Effect::set_effect(const char* value, size_t size) {
  
  effect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NullSpaceHaptics.Effect.effect)
}
 ::std::string* Effect::mutable_effect() {
  
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.Effect.effect)
  return effect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Effect::release_effect() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.Effect.effect)
  
  return effect_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Effect::set_allocated_effect(::std::string* effect) {
  if (effect != NULL) {
    
  } else {
    
  }
  effect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), effect);
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.Effect.effect)
}

// optional float strength = 3;
void Effect::clear_strength() {
  strength_ = 0;
}
 float Effect::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Effect.strength)
  return strength_;
}
 void Effect::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Effect.strength)
}

// optional float duration = 4;
void Effect::clear_duration() {
  duration_ = 0;
}
 float Effect::duration() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Effect.duration)
  return duration_;
}
 void Effect::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Effect.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Sequence::kEffectsFieldNumber;
const int Sequence::kTimeFieldNumber;
const int Sequence::kStrengthFieldNumber;
const int Sequence::kAreaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Sequence::Sequence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.Sequence)
}

void Sequence::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Sequence::Sequence(const Sequence& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.Sequence)
}

void Sequence::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  time_ = 0;
  strength_ = 0;
  area_ = 0u;
}

Sequence::~Sequence() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.Sequence)
  SharedDtor();
}

void Sequence::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Sequence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sequence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sequence_descriptor_;
}

const Sequence& Sequence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

Sequence* Sequence::default_instance_ = NULL;

Sequence* Sequence::New(::google::protobuf::Arena* arena) const {
  Sequence* n = new Sequence;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Sequence::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.Sequence)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Sequence, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Sequence*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(time_, area_);

#undef ZR_HELPER_
#undef ZR_

  effects_.Clear();
}

bool Sequence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.Sequence)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .NullSpaceHaptics.Effect effects = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_effects:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_effects()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_effects;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(21)) goto parse_time;
        break;
      }

      // optional float time = 2;
      case 2: {
        if (tag == 21) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_strength;
        break;
      }

      // optional float strength = 3;
      case 3: {
        if (tag == 29) {
         parse_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &strength_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_area;
        break;
      }

      // optional uint32 area = 4;
      case 4: {
        if (tag == 32) {
         parse_area:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &area_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.Sequence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.Sequence)
  return false;
#undef DO_
}

void Sequence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.Sequence)
  // repeated .NullSpaceHaptics.Effect effects = 1;
  for (unsigned int i = 0, n = this->effects_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->effects(i), output);
  }

  // optional float time = 2;
  if (this->time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->time(), output);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->strength(), output);
  }

  // optional uint32 area = 4;
  if (this->area() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->area(), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.Sequence)
}

::google::protobuf::uint8* Sequence::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.Sequence)
  // repeated .NullSpaceHaptics.Effect effects = 1;
  for (unsigned int i = 0, n = this->effects_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->effects(i), false, target);
  }

  // optional float time = 2;
  if (this->time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->time(), target);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->strength(), target);
  }

  // optional uint32 area = 4;
  if (this->area() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->area(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.Sequence)
  return target;
}

int Sequence::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.Sequence)
  int total_size = 0;

  // optional float time = 2;
  if (this->time() != 0) {
    total_size += 1 + 4;
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    total_size += 1 + 4;
  }

  // optional uint32 area = 4;
  if (this->area() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->area());
  }

  // repeated .NullSpaceHaptics.Effect effects = 1;
  total_size += 1 * this->effects_size();
  for (int i = 0; i < this->effects_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->effects(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sequence::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.Sequence)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Sequence* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Sequence>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.Sequence)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.Sequence)
    MergeFrom(*source);
  }
}

void Sequence::MergeFrom(const Sequence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.Sequence)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  effects_.MergeFrom(from.effects_);
  if (from.time() != 0) {
    set_time(from.time());
  }
  if (from.strength() != 0) {
    set_strength(from.strength());
  }
  if (from.area() != 0) {
    set_area(from.area());
  }
}

void Sequence::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.Sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sequence::CopyFrom(const Sequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.Sequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sequence::IsInitialized() const {

  return true;
}

void Sequence::Swap(Sequence* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Sequence::InternalSwap(Sequence* other) {
  effects_.UnsafeArenaSwap(&other->effects_);
  std::swap(time_, other->time_);
  std::swap(strength_, other->strength_);
  std::swap(area_, other->area_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Sequence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sequence_descriptor_;
  metadata.reflection = Sequence_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Sequence

// repeated .NullSpaceHaptics.Effect effects = 1;
int Sequence::effects_size() const {
  return effects_.size();
}
void Sequence::clear_effects() {
  effects_.Clear();
}
const ::NullSpaceHaptics::Effect& Sequence::effects(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Sequence.effects)
  return effects_.Get(index);
}
::NullSpaceHaptics::Effect* Sequence::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.Sequence.effects)
  return effects_.Mutable(index);
}
::NullSpaceHaptics::Effect* Sequence::add_effects() {
  // @@protoc_insertion_point(field_add:NullSpaceHaptics.Sequence.effects)
  return effects_.Add();
}
::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Effect >*
Sequence::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceHaptics.Sequence.effects)
  return &effects_;
}
const ::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Effect >&
Sequence::effects() const {
  // @@protoc_insertion_point(field_list:NullSpaceHaptics.Sequence.effects)
  return effects_;
}

// optional float time = 2;
void Sequence::clear_time() {
  time_ = 0;
}
 float Sequence::time() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Sequence.time)
  return time_;
}
 void Sequence::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Sequence.time)
}

// optional float strength = 3;
void Sequence::clear_strength() {
  strength_ = 0;
}
 float Sequence::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Sequence.strength)
  return strength_;
}
 void Sequence::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Sequence.strength)
}

// optional uint32 area = 4;
void Sequence::clear_area() {
  area_ = 0u;
}
 ::google::protobuf::uint32 Sequence::area() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Sequence.area)
  return area_;
}
 void Sequence::set_area(::google::protobuf::uint32 value) {
  
  area_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Sequence.area)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pattern::kSequencesFieldNumber;
const int Pattern::kTimeFieldNumber;
const int Pattern::kStrengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pattern::Pattern()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.Pattern)
}

void Pattern::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Pattern::Pattern(const Pattern& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.Pattern)
}

void Pattern::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  time_ = 0;
  strength_ = 0;
}

Pattern::~Pattern() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.Pattern)
  SharedDtor();
}

void Pattern::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Pattern::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pattern::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pattern_descriptor_;
}

const Pattern& Pattern::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

Pattern* Pattern::default_instance_ = NULL;

Pattern* Pattern::New(::google::protobuf::Arena* arena) const {
  Pattern* n = new Pattern;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pattern::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.Pattern)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Pattern, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Pattern*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(time_, strength_);

#undef ZR_HELPER_
#undef ZR_

  sequences_.Clear();
}

bool Pattern::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.Pattern)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .NullSpaceHaptics.Sequence sequences = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_sequences:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_sequences()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_sequences;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(21)) goto parse_time;
        break;
      }

      // optional float time = 2;
      case 2: {
        if (tag == 21) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_strength;
        break;
      }

      // optional float strength = 3;
      case 3: {
        if (tag == 29) {
         parse_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &strength_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.Pattern)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.Pattern)
  return false;
#undef DO_
}

void Pattern::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.Pattern)
  // repeated .NullSpaceHaptics.Sequence sequences = 1;
  for (unsigned int i = 0, n = this->sequences_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sequences(i), output);
  }

  // optional float time = 2;
  if (this->time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->time(), output);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->strength(), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.Pattern)
}

::google::protobuf::uint8* Pattern::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.Pattern)
  // repeated .NullSpaceHaptics.Sequence sequences = 1;
  for (unsigned int i = 0, n = this->sequences_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->sequences(i), false, target);
  }

  // optional float time = 2;
  if (this->time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->time(), target);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->strength(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.Pattern)
  return target;
}

int Pattern::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.Pattern)
  int total_size = 0;

  // optional float time = 2;
  if (this->time() != 0) {
    total_size += 1 + 4;
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    total_size += 1 + 4;
  }

  // repeated .NullSpaceHaptics.Sequence sequences = 1;
  total_size += 1 * this->sequences_size();
  for (int i = 0; i < this->sequences_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sequences(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pattern::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.Pattern)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Pattern* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Pattern>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.Pattern)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.Pattern)
    MergeFrom(*source);
  }
}

void Pattern::MergeFrom(const Pattern& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.Pattern)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  sequences_.MergeFrom(from.sequences_);
  if (from.time() != 0) {
    set_time(from.time());
  }
  if (from.strength() != 0) {
    set_strength(from.strength());
  }
}

void Pattern::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.Pattern)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pattern::CopyFrom(const Pattern& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.Pattern)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pattern::IsInitialized() const {

  return true;
}

void Pattern::Swap(Pattern* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pattern::InternalSwap(Pattern* other) {
  sequences_.UnsafeArenaSwap(&other->sequences_);
  std::swap(time_, other->time_);
  std::swap(strength_, other->strength_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pattern::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pattern_descriptor_;
  metadata.reflection = Pattern_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pattern

// repeated .NullSpaceHaptics.Sequence sequences = 1;
int Pattern::sequences_size() const {
  return sequences_.size();
}
void Pattern::clear_sequences() {
  sequences_.Clear();
}
const ::NullSpaceHaptics::Sequence& Pattern::sequences(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Pattern.sequences)
  return sequences_.Get(index);
}
::NullSpaceHaptics::Sequence* Pattern::mutable_sequences(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.Pattern.sequences)
  return sequences_.Mutable(index);
}
::NullSpaceHaptics::Sequence* Pattern::add_sequences() {
  // @@protoc_insertion_point(field_add:NullSpaceHaptics.Pattern.sequences)
  return sequences_.Add();
}
::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Sequence >*
Pattern::mutable_sequences() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceHaptics.Pattern.sequences)
  return &sequences_;
}
const ::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Sequence >&
Pattern::sequences() const {
  // @@protoc_insertion_point(field_list:NullSpaceHaptics.Pattern.sequences)
  return sequences_;
}

// optional float time = 2;
void Pattern::clear_time() {
  time_ = 0;
}
 float Pattern::time() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Pattern.time)
  return time_;
}
 void Pattern::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Pattern.time)
}

// optional float strength = 3;
void Pattern::clear_strength() {
  strength_ = 0;
}
 float Pattern::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Pattern.strength)
  return strength_;
}
 void Pattern::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Pattern.strength)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Experience::kPatternsFieldNumber;
const int Experience::kTimeFieldNumber;
const int Experience::kStrengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Experience::Experience()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.Experience)
}

void Experience::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Experience::Experience(const Experience& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.Experience)
}

void Experience::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  time_ = 0;
  strength_ = 0;
}

Experience::~Experience() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.Experience)
  SharedDtor();
}

void Experience::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Experience::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Experience::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Experience_descriptor_;
}

const Experience& Experience::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

Experience* Experience::default_instance_ = NULL;

Experience* Experience::New(::google::protobuf::Arena* arena) const {
  Experience* n = new Experience;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Experience::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.Experience)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Experience, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Experience*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(time_, strength_);

#undef ZR_HELPER_
#undef ZR_

  patterns_.Clear();
}

bool Experience::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.Experience)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .NullSpaceHaptics.Pattern patterns = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_patterns:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_patterns()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_patterns;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(21)) goto parse_time;
        break;
      }

      // optional float time = 2;
      case 2: {
        if (tag == 21) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_strength;
        break;
      }

      // optional float strength = 3;
      case 3: {
        if (tag == 29) {
         parse_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &strength_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.Experience)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.Experience)
  return false;
#undef DO_
}

void Experience::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.Experience)
  // repeated .NullSpaceHaptics.Pattern patterns = 1;
  for (unsigned int i = 0, n = this->patterns_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->patterns(i), output);
  }

  // optional float time = 2;
  if (this->time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->time(), output);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->strength(), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.Experience)
}

::google::protobuf::uint8* Experience::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.Experience)
  // repeated .NullSpaceHaptics.Pattern patterns = 1;
  for (unsigned int i = 0, n = this->patterns_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->patterns(i), false, target);
  }

  // optional float time = 2;
  if (this->time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->time(), target);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->strength(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.Experience)
  return target;
}

int Experience::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.Experience)
  int total_size = 0;

  // optional float time = 2;
  if (this->time() != 0) {
    total_size += 1 + 4;
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    total_size += 1 + 4;
  }

  // repeated .NullSpaceHaptics.Pattern patterns = 1;
  total_size += 1 * this->patterns_size();
  for (int i = 0; i < this->patterns_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->patterns(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Experience::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.Experience)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Experience* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Experience>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.Experience)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.Experience)
    MergeFrom(*source);
  }
}

void Experience::MergeFrom(const Experience& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.Experience)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  patterns_.MergeFrom(from.patterns_);
  if (from.time() != 0) {
    set_time(from.time());
  }
  if (from.strength() != 0) {
    set_strength(from.strength());
  }
}

void Experience::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.Experience)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Experience::CopyFrom(const Experience& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.Experience)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Experience::IsInitialized() const {

  return true;
}

void Experience::Swap(Experience* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Experience::InternalSwap(Experience* other) {
  patterns_.UnsafeArenaSwap(&other->patterns_);
  std::swap(time_, other->time_);
  std::swap(strength_, other->strength_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Experience::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Experience_descriptor_;
  metadata.reflection = Experience_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Experience

// repeated .NullSpaceHaptics.Pattern patterns = 1;
int Experience::patterns_size() const {
  return patterns_.size();
}
void Experience::clear_patterns() {
  patterns_.Clear();
}
const ::NullSpaceHaptics::Pattern& Experience::patterns(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Experience.patterns)
  return patterns_.Get(index);
}
::NullSpaceHaptics::Pattern* Experience::mutable_patterns(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.Experience.patterns)
  return patterns_.Mutable(index);
}
::NullSpaceHaptics::Pattern* Experience::add_patterns() {
  // @@protoc_insertion_point(field_add:NullSpaceHaptics.Experience.patterns)
  return patterns_.Add();
}
::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Pattern >*
Experience::mutable_patterns() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceHaptics.Experience.patterns)
  return &patterns_;
}
const ::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Pattern >&
Experience::patterns() const {
  // @@protoc_insertion_point(field_list:NullSpaceHaptics.Experience.patterns)
  return patterns_;
}

// optional float time = 2;
void Experience::clear_time() {
  time_ = 0;
}
 float Experience::time() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Experience.time)
  return time_;
}
 void Experience::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Experience.time)
}

// optional float strength = 3;
void Experience::clear_strength() {
  strength_ = 0;
}
 float Experience::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.Experience.strength)
  return strength_;
}
 void Experience::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.Experience.strength)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* HapticFile_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HapticFile_Type_descriptor_;
}
bool HapticFile_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const HapticFile_Type HapticFile::UNKNOWN;
const HapticFile_Type HapticFile::SEQUENCE;
const HapticFile_Type HapticFile::PATTERN;
const HapticFile_Type HapticFile::EXPERIENCE;
const HapticFile_Type HapticFile::Type_MIN;
const HapticFile_Type HapticFile::Type_MAX;
const int HapticFile::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HapticFile::kTypeFieldNumber;
const int HapticFile::kSequenceFieldNumber;
const int HapticFile::kPatternFieldNumber;
const int HapticFile::kExperienceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HapticFile::HapticFile()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.HapticFile)
}

void HapticFile::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  sequence_ = const_cast< ::NullSpaceHaptics::Sequence*>(&::NullSpaceHaptics::Sequence::default_instance());
  pattern_ = const_cast< ::NullSpaceHaptics::Pattern*>(&::NullSpaceHaptics::Pattern::default_instance());
  experience_ = const_cast< ::NullSpaceHaptics::Experience*>(&::NullSpaceHaptics::Experience::default_instance());
}

HapticFile::HapticFile(const HapticFile& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.HapticFile)
}

void HapticFile::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  type_ = 0;
  sequence_ = NULL;
  pattern_ = NULL;
  experience_ = NULL;
}

HapticFile::~HapticFile() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.HapticFile)
  SharedDtor();
}

void HapticFile::SharedDtor() {
  if (this != default_instance_) {
    delete sequence_;
    delete pattern_;
    delete experience_;
  }
}

void HapticFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HapticFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HapticFile_descriptor_;
}

const HapticFile& HapticFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

HapticFile* HapticFile::default_instance_ = NULL;

HapticFile* HapticFile::New(::google::protobuf::Arena* arena) const {
  HapticFile* n = new HapticFile;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HapticFile::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.HapticFile)
  type_ = 0;
  if (GetArenaNoVirtual() == NULL && sequence_ != NULL) delete sequence_;
  sequence_ = NULL;
  if (GetArenaNoVirtual() == NULL && pattern_ != NULL) delete pattern_;
  pattern_ = NULL;
  if (GetArenaNoVirtual() == NULL && experience_ != NULL) delete experience_;
  experience_ = NULL;
}

bool HapticFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.HapticFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .NullSpaceHaptics.HapticFile.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::NullSpaceHaptics::HapticFile_Type >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sequence;
        break;
      }

      // optional .NullSpaceHaptics.Sequence sequence = 2;
      case 2: {
        if (tag == 18) {
         parse_sequence:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sequence()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pattern;
        break;
      }

      // optional .NullSpaceHaptics.Pattern pattern = 3;
      case 3: {
        if (tag == 26) {
         parse_pattern:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pattern()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_experience;
        break;
      }

      // optional .NullSpaceHaptics.Experience experience = 4;
      case 4: {
        if (tag == 34) {
         parse_experience:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_experience()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.HapticFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.HapticFile)
  return false;
#undef DO_
}

void HapticFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.HapticFile)
  // optional .NullSpaceHaptics.HapticFile.Type type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .NullSpaceHaptics.Sequence sequence = 2;
  if (this->has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->sequence_, output);
  }

  // optional .NullSpaceHaptics.Pattern pattern = 3;
  if (this->has_pattern()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->pattern_, output);
  }

  // optional .NullSpaceHaptics.Experience experience = 4;
  if (this->has_experience()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->experience_, output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.HapticFile)
}

::google::protobuf::uint8* HapticFile::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.HapticFile)
  // optional .NullSpaceHaptics.HapticFile.Type type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .NullSpaceHaptics.Sequence sequence = 2;
  if (this->has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->sequence_, false, target);
  }

  // optional .NullSpaceHaptics.Pattern pattern = 3;
  if (this->has_pattern()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->pattern_, false, target);
  }

  // optional .NullSpaceHaptics.Experience experience = 4;
  if (this->has_experience()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->experience_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.HapticFile)
  return target;
}

int HapticFile::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.HapticFile)
  int total_size = 0;

  // optional .NullSpaceHaptics.HapticFile.Type type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional .NullSpaceHaptics.Sequence sequence = 2;
  if (this->has_sequence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->sequence_);
  }

  // optional .NullSpaceHaptics.Pattern pattern = 3;
  if (this->has_pattern()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pattern_);
  }

  // optional .NullSpaceHaptics.Experience experience = 4;
  if (this->has_experience()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->experience_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HapticFile::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.HapticFile)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HapticFile* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HapticFile>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.HapticFile)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.HapticFile)
    MergeFrom(*source);
  }
}

void HapticFile::MergeFrom(const HapticFile& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.HapticFile)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.has_sequence()) {
    mutable_sequence()->::NullSpaceHaptics::Sequence::MergeFrom(from.sequence());
  }
  if (from.has_pattern()) {
    mutable_pattern()->::NullSpaceHaptics::Pattern::MergeFrom(from.pattern());
  }
  if (from.has_experience()) {
    mutable_experience()->::NullSpaceHaptics::Experience::MergeFrom(from.experience());
  }
}

void HapticFile::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.HapticFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HapticFile::CopyFrom(const HapticFile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.HapticFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HapticFile::IsInitialized() const {

  return true;
}

void HapticFile::Swap(HapticFile* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HapticFile::InternalSwap(HapticFile* other) {
  std::swap(type_, other->type_);
  std::swap(sequence_, other->sequence_);
  std::swap(pattern_, other->pattern_);
  std::swap(experience_, other->experience_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HapticFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HapticFile_descriptor_;
  metadata.reflection = HapticFile_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HapticFile

// optional .NullSpaceHaptics.HapticFile.Type type = 1;
void HapticFile::clear_type() {
  type_ = 0;
}
 ::NullSpaceHaptics::HapticFile_Type HapticFile::type() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.HapticFile.type)
  return static_cast< ::NullSpaceHaptics::HapticFile_Type >(type_);
}
 void HapticFile::set_type(::NullSpaceHaptics::HapticFile_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.HapticFile.type)
}

// optional .NullSpaceHaptics.Sequence sequence = 2;
bool HapticFile::has_sequence() const {
  return !_is_default_instance_ && sequence_ != NULL;
}
void HapticFile::clear_sequence() {
  if (GetArenaNoVirtual() == NULL && sequence_ != NULL) delete sequence_;
  sequence_ = NULL;
}
const ::NullSpaceHaptics::Sequence& HapticFile::sequence() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.HapticFile.sequence)
  return sequence_ != NULL ? *sequence_ : *default_instance_->sequence_;
}
::NullSpaceHaptics::Sequence* HapticFile::mutable_sequence() {
  
  if (sequence_ == NULL) {
    sequence_ = new ::NullSpaceHaptics::Sequence;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.HapticFile.sequence)
  return sequence_;
}
::NullSpaceHaptics::Sequence* HapticFile::release_sequence() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.HapticFile.sequence)
  
  ::NullSpaceHaptics::Sequence* temp = sequence_;
  sequence_ = NULL;
  return temp;
}
void HapticFile::set_allocated_sequence(::NullSpaceHaptics::Sequence* sequence) {
  delete sequence_;
  sequence_ = sequence;
  if (sequence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.HapticFile.sequence)
}

// optional .NullSpaceHaptics.Pattern pattern = 3;
bool HapticFile::has_pattern() const {
  return !_is_default_instance_ && pattern_ != NULL;
}
void HapticFile::clear_pattern() {
  if (GetArenaNoVirtual() == NULL && pattern_ != NULL) delete pattern_;
  pattern_ = NULL;
}
const ::NullSpaceHaptics::Pattern& HapticFile::pattern() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.HapticFile.pattern)
  return pattern_ != NULL ? *pattern_ : *default_instance_->pattern_;
}
::NullSpaceHaptics::Pattern* HapticFile::mutable_pattern() {
  
  if (pattern_ == NULL) {
    pattern_ = new ::NullSpaceHaptics::Pattern;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.HapticFile.pattern)
  return pattern_;
}
::NullSpaceHaptics::Pattern* HapticFile::release_pattern() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.HapticFile.pattern)
  
  ::NullSpaceHaptics::Pattern* temp = pattern_;
  pattern_ = NULL;
  return temp;
}
void HapticFile::set_allocated_pattern(::NullSpaceHaptics::Pattern* pattern) {
  delete pattern_;
  pattern_ = pattern;
  if (pattern) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.HapticFile.pattern)
}

// optional .NullSpaceHaptics.Experience experience = 4;
bool HapticFile::has_experience() const {
  return !_is_default_instance_ && experience_ != NULL;
}
void HapticFile::clear_experience() {
  if (GetArenaNoVirtual() == NULL && experience_ != NULL) delete experience_;
  experience_ = NULL;
}
const ::NullSpaceHaptics::Experience& HapticFile::experience() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.HapticFile.experience)
  return experience_ != NULL ? *experience_ : *default_instance_->experience_;
}
::NullSpaceHaptics::Experience* HapticFile::mutable_experience() {
  
  if (experience_ == NULL) {
    experience_ = new ::NullSpaceHaptics::Experience;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.HapticFile.experience)
  return experience_;
}
::NullSpaceHaptics::Experience* HapticFile::release_experience() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.HapticFile.experience)
  
  ::NullSpaceHaptics::Experience* temp = experience_;
  experience_ = NULL;
  return temp;
}
void HapticFile::set_allocated_experience(::NullSpaceHaptics::Experience* experience) {
  delete experience_;
  experience_ = experience;
  if (experience) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.HapticFile.experience)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* RootEffect_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RootEffect_Type_descriptor_;
}
bool RootEffect_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RootEffect_Type RootEffect::UNKNOWN;
const RootEffect_Type RootEffect::SEQUENCE;
const RootEffect_Type RootEffect::PATTERN;
const RootEffect_Type RootEffect::EXPERIENCE;
const RootEffect_Type RootEffect::Type_MIN;
const RootEffect_Type RootEffect::Type_MAX;
const int RootEffect::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RootEffect::kNameFieldNumber;
const int RootEffect::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RootEffect::RootEffect()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.RootEffect)
}

void RootEffect::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

RootEffect::RootEffect(const RootEffect& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.RootEffect)
}

void RootEffect::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
}

RootEffect::~RootEffect() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.RootEffect)
  SharedDtor();
}

void RootEffect::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RootEffect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RootEffect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RootEffect_descriptor_;
}

const RootEffect& RootEffect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

RootEffect* RootEffect::default_instance_ = NULL;

RootEffect* RootEffect::New(::google::protobuf::Arena* arena) const {
  RootEffect* n = new RootEffect;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RootEffect::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.RootEffect)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
}

bool RootEffect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.RootEffect)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "NullSpaceHaptics.RootEffect.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .NullSpaceHaptics.RootEffect.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::NullSpaceHaptics::RootEffect_Type >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.RootEffect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.RootEffect)
  return false;
#undef DO_
}

void RootEffect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.RootEffect)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.RootEffect.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .NullSpaceHaptics.RootEffect.Type type = 2;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.RootEffect)
}

::google::protobuf::uint8* RootEffect::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.RootEffect)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.RootEffect.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .NullSpaceHaptics.RootEffect.Type type = 2;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.RootEffect)
  return target;
}

int RootEffect::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.RootEffect)
  int total_size = 0;

  // optional string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // optional .NullSpaceHaptics.RootEffect.Type type = 2;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RootEffect::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.RootEffect)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RootEffect* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RootEffect>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.RootEffect)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.RootEffect)
    MergeFrom(*source);
  }
}

void RootEffect::MergeFrom(const RootEffect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.RootEffect)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void RootEffect::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.RootEffect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RootEffect::CopyFrom(const RootEffect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.RootEffect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RootEffect::IsInitialized() const {

  return true;
}

void RootEffect::Swap(RootEffect* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RootEffect::InternalSwap(RootEffect* other) {
  name_.Swap(&other->name_);
  std::swap(type_, other->type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RootEffect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RootEffect_descriptor_;
  metadata.reflection = RootEffect_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RootEffect

// optional string name = 1;
void RootEffect::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& RootEffect::name() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.RootEffect.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RootEffect::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.RootEffect.name)
}
 void RootEffect::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NullSpaceHaptics.RootEffect.name)
}
 void RootEffect::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NullSpaceHaptics.RootEffect.name)
}
 ::std::string* RootEffect::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.RootEffect.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RootEffect::release_name() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.RootEffect.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RootEffect::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.RootEffect.name)
}

// optional .NullSpaceHaptics.RootEffect.Type type = 2;
void RootEffect::clear_type() {
  type_ = 0;
}
 ::NullSpaceHaptics::RootEffect_Type RootEffect::type() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.RootEffect.type)
  return static_cast< ::NullSpaceHaptics::RootEffect_Type >(type_);
}
 void RootEffect::set_type(::NullSpaceHaptics::RootEffect_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.RootEffect.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PatternNode::kTimeFieldNumber;
const int PatternNode::kSequenceFieldNumber;
const int PatternNode::kAreaFieldNumber;
const int PatternNode::kStrengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PatternNode::PatternNode()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.PatternNode)
}

void PatternNode::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

PatternNode::PatternNode(const PatternNode& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.PatternNode)
}

void PatternNode::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  time_ = 0;
  sequence_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  area_ = 0u;
  strength_ = 0;
}

PatternNode::~PatternNode() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.PatternNode)
  SharedDtor();
}

void PatternNode::SharedDtor() {
  sequence_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void PatternNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PatternNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PatternNode_descriptor_;
}

const PatternNode& PatternNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

PatternNode* PatternNode::default_instance_ = NULL;

PatternNode* PatternNode::New(::google::protobuf::Arena* arena) const {
  PatternNode* n = new PatternNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PatternNode::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.PatternNode)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PatternNode, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PatternNode*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(time_, strength_);
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool PatternNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.PatternNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sequence;
        break;
      }

      // optional string sequence = 2;
      case 2: {
        if (tag == 18) {
         parse_sequence:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sequence()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->sequence().data(), this->sequence().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "NullSpaceHaptics.PatternNode.sequence"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_area;
        break;
      }

      // optional uint32 area = 3;
      case 3: {
        if (tag == 24) {
         parse_area:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &area_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_strength;
        break;
      }

      // optional float strength = 4;
      case 4: {
        if (tag == 37) {
         parse_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &strength_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.PatternNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.PatternNode)
  return false;
#undef DO_
}

void PatternNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.PatternNode)
  // optional float time = 1;
  if (this->time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }

  // optional string sequence = 2;
  if (this->sequence().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sequence().data(), this->sequence().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.PatternNode.sequence");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sequence(), output);
  }

  // optional uint32 area = 3;
  if (this->area() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->area(), output);
  }

  // optional float strength = 4;
  if (this->strength() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->strength(), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.PatternNode)
}

::google::protobuf::uint8* PatternNode::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.PatternNode)
  // optional float time = 1;
  if (this->time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->time(), target);
  }

  // optional string sequence = 2;
  if (this->sequence().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->sequence().data(), this->sequence().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.PatternNode.sequence");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->sequence(), target);
  }

  // optional uint32 area = 3;
  if (this->area() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->area(), target);
  }

  // optional float strength = 4;
  if (this->strength() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->strength(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.PatternNode)
  return target;
}

int PatternNode::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.PatternNode)
  int total_size = 0;

  // optional float time = 1;
  if (this->time() != 0) {
    total_size += 1 + 4;
  }

  // optional string sequence = 2;
  if (this->sequence().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sequence());
  }

  // optional uint32 area = 3;
  if (this->area() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->area());
  }

  // optional float strength = 4;
  if (this->strength() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PatternNode::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.PatternNode)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PatternNode* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PatternNode>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.PatternNode)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.PatternNode)
    MergeFrom(*source);
  }
}

void PatternNode::MergeFrom(const PatternNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.PatternNode)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.time() != 0) {
    set_time(from.time());
  }
  if (from.sequence().size() > 0) {

    sequence_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sequence_);
  }
  if (from.area() != 0) {
    set_area(from.area());
  }
  if (from.strength() != 0) {
    set_strength(from.strength());
  }
}

void PatternNode::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.PatternNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PatternNode::CopyFrom(const PatternNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.PatternNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PatternNode::IsInitialized() const {

  return true;
}

void PatternNode::Swap(PatternNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PatternNode::InternalSwap(PatternNode* other) {
  std::swap(time_, other->time_);
  sequence_.Swap(&other->sequence_);
  std::swap(area_, other->area_);
  std::swap(strength_, other->strength_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PatternNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PatternNode_descriptor_;
  metadata.reflection = PatternNode_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PatternNode

// optional float time = 1;
void PatternNode::clear_time() {
  time_ = 0;
}
 float PatternNode::time() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.PatternNode.time)
  return time_;
}
 void PatternNode::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.PatternNode.time)
}

// optional string sequence = 2;
void PatternNode::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PatternNode::sequence() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.PatternNode.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PatternNode::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.PatternNode.sequence)
}
 void PatternNode::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NullSpaceHaptics.PatternNode.sequence)
}
 void PatternNode::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NullSpaceHaptics.PatternNode.sequence)
}
 ::std::string* PatternNode::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.PatternNode.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PatternNode::release_sequence() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.PatternNode.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PatternNode::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.PatternNode.sequence)
}

// optional uint32 area = 3;
void PatternNode::clear_area() {
  area_ = 0u;
}
 ::google::protobuf::uint32 PatternNode::area() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.PatternNode.area)
  return area_;
}
 void PatternNode::set_area(::google::protobuf::uint32 value) {
  
  area_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.PatternNode.area)
}

// optional float strength = 4;
void PatternNode::clear_strength() {
  strength_ = 0;
}
 float PatternNode::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.PatternNode.strength)
  return strength_;
}
 void PatternNode::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.PatternNode.strength)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExperienceNode::kTimeFieldNumber;
const int ExperienceNode::kPatternFieldNumber;
const int ExperienceNode::kStrengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExperienceNode::ExperienceNode()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.ExperienceNode)
}

void ExperienceNode::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ExperienceNode::ExperienceNode(const ExperienceNode& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.ExperienceNode)
}

void ExperienceNode::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  time_ = 0;
  pattern_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  strength_ = 0;
}

ExperienceNode::~ExperienceNode() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.ExperienceNode)
  SharedDtor();
}

void ExperienceNode::SharedDtor() {
  pattern_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ExperienceNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExperienceNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExperienceNode_descriptor_;
}

const ExperienceNode& ExperienceNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

ExperienceNode* ExperienceNode::default_instance_ = NULL;

ExperienceNode* ExperienceNode::New(::google::protobuf::Arena* arena) const {
  ExperienceNode* n = new ExperienceNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ExperienceNode::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.ExperienceNode)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ExperienceNode, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ExperienceNode*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(time_, strength_);
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool ExperienceNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.ExperienceNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pattern;
        break;
      }

      // optional string pattern = 2;
      case 2: {
        if (tag == 18) {
         parse_pattern:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pattern()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->pattern().data(), this->pattern().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "NullSpaceHaptics.ExperienceNode.pattern"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_strength;
        break;
      }

      // optional float strength = 3;
      case 3: {
        if (tag == 29) {
         parse_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &strength_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.ExperienceNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.ExperienceNode)
  return false;
#undef DO_
}

void ExperienceNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.ExperienceNode)
  // optional float time = 1;
  if (this->time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }

  // optional string pattern = 2;
  if (this->pattern().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->pattern().data(), this->pattern().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.ExperienceNode.pattern");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pattern(), output);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->strength(), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.ExperienceNode)
}

::google::protobuf::uint8* ExperienceNode::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.ExperienceNode)
  // optional float time = 1;
  if (this->time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->time(), target);
  }

  // optional string pattern = 2;
  if (this->pattern().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->pattern().data(), this->pattern().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "NullSpaceHaptics.ExperienceNode.pattern");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pattern(), target);
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->strength(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.ExperienceNode)
  return target;
}

int ExperienceNode::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.ExperienceNode)
  int total_size = 0;

  // optional float time = 1;
  if (this->time() != 0) {
    total_size += 1 + 4;
  }

  // optional string pattern = 2;
  if (this->pattern().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->pattern());
  }

  // optional float strength = 3;
  if (this->strength() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExperienceNode::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.ExperienceNode)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ExperienceNode* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ExperienceNode>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.ExperienceNode)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.ExperienceNode)
    MergeFrom(*source);
  }
}

void ExperienceNode::MergeFrom(const ExperienceNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.ExperienceNode)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.time() != 0) {
    set_time(from.time());
  }
  if (from.pattern().size() > 0) {

    pattern_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pattern_);
  }
  if (from.strength() != 0) {
    set_strength(from.strength());
  }
}

void ExperienceNode::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.ExperienceNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExperienceNode::CopyFrom(const ExperienceNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.ExperienceNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExperienceNode::IsInitialized() const {

  return true;
}

void ExperienceNode::Swap(ExperienceNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExperienceNode::InternalSwap(ExperienceNode* other) {
  std::swap(time_, other->time_);
  pattern_.Swap(&other->pattern_);
  std::swap(strength_, other->strength_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ExperienceNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExperienceNode_descriptor_;
  metadata.reflection = ExperienceNode_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ExperienceNode

// optional float time = 1;
void ExperienceNode::clear_time() {
  time_ = 0;
}
 float ExperienceNode::time() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.ExperienceNode.time)
  return time_;
}
 void ExperienceNode::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.ExperienceNode.time)
}

// optional string pattern = 2;
void ExperienceNode::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& ExperienceNode::pattern() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.ExperienceNode.pattern)
  return pattern_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExperienceNode::set_pattern(const ::std::string& value) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.ExperienceNode.pattern)
}
 void ExperienceNode::set_pattern(const char* value) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NullSpaceHaptics.ExperienceNode.pattern)
}
 void ExperienceNode::set_pattern(const char* value, size_t size) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NullSpaceHaptics.ExperienceNode.pattern)
}
 ::std::string* ExperienceNode::mutable_pattern() {
  
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.ExperienceNode.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExperienceNode::release_pattern() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.ExperienceNode.pattern)
  
  return pattern_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExperienceNode::set_allocated_pattern(::std::string* pattern) {
  if (pattern != NULL) {
    
  } else {
    
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.ExperienceNode.pattern)
}

// optional float strength = 3;
void ExperienceNode::clear_strength() {
  strength_ = 0;
}
 float ExperienceNode::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.ExperienceNode.strength)
  return strength_;
}
 void ExperienceNode::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceHaptics.ExperienceNode.strength)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SequenceDefinitions::kEffectsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SequenceDefinitions::SequenceDefinitions()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.SequenceDefinitions)
}

void SequenceDefinitions::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

SequenceDefinitions::SequenceDefinitions(const SequenceDefinitions& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.SequenceDefinitions)
}

void SequenceDefinitions::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

SequenceDefinitions::~SequenceDefinitions() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.SequenceDefinitions)
  SharedDtor();
}

void SequenceDefinitions::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SequenceDefinitions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SequenceDefinitions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SequenceDefinitions_descriptor_;
}

const SequenceDefinitions& SequenceDefinitions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

SequenceDefinitions* SequenceDefinitions::default_instance_ = NULL;

SequenceDefinitions* SequenceDefinitions::New(::google::protobuf::Arena* arena) const {
  SequenceDefinitions* n = new SequenceDefinitions;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SequenceDefinitions::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.SequenceDefinitions)
  effects_.Clear();
}

bool SequenceDefinitions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.SequenceDefinitions)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .NullSpaceHaptics.Effect effects = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_effects:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_effects()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_effects;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.SequenceDefinitions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.SequenceDefinitions)
  return false;
#undef DO_
}

void SequenceDefinitions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.SequenceDefinitions)
  // repeated .NullSpaceHaptics.Effect effects = 1;
  for (unsigned int i = 0, n = this->effects_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->effects(i), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.SequenceDefinitions)
}

::google::protobuf::uint8* SequenceDefinitions::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.SequenceDefinitions)
  // repeated .NullSpaceHaptics.Effect effects = 1;
  for (unsigned int i = 0, n = this->effects_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->effects(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.SequenceDefinitions)
  return target;
}

int SequenceDefinitions::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.SequenceDefinitions)
  int total_size = 0;

  // repeated .NullSpaceHaptics.Effect effects = 1;
  total_size += 1 * this->effects_size();
  for (int i = 0; i < this->effects_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->effects(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SequenceDefinitions::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.SequenceDefinitions)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SequenceDefinitions* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SequenceDefinitions>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.SequenceDefinitions)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.SequenceDefinitions)
    MergeFrom(*source);
  }
}

void SequenceDefinitions::MergeFrom(const SequenceDefinitions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.SequenceDefinitions)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  effects_.MergeFrom(from.effects_);
}

void SequenceDefinitions::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.SequenceDefinitions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SequenceDefinitions::CopyFrom(const SequenceDefinitions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.SequenceDefinitions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequenceDefinitions::IsInitialized() const {

  return true;
}

void SequenceDefinitions::Swap(SequenceDefinitions* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SequenceDefinitions::InternalSwap(SequenceDefinitions* other) {
  effects_.UnsafeArenaSwap(&other->effects_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SequenceDefinitions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SequenceDefinitions_descriptor_;
  metadata.reflection = SequenceDefinitions_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SequenceDefinitions

// repeated .NullSpaceHaptics.Effect effects = 1;
int SequenceDefinitions::effects_size() const {
  return effects_.size();
}
void SequenceDefinitions::clear_effects() {
  effects_.Clear();
}
const ::NullSpaceHaptics::Effect& SequenceDefinitions::effects(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.SequenceDefinitions.effects)
  return effects_.Get(index);
}
::NullSpaceHaptics::Effect* SequenceDefinitions::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.SequenceDefinitions.effects)
  return effects_.Mutable(index);
}
::NullSpaceHaptics::Effect* SequenceDefinitions::add_effects() {
  // @@protoc_insertion_point(field_add:NullSpaceHaptics.SequenceDefinitions.effects)
  return effects_.Add();
}
::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Effect >*
SequenceDefinitions::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceHaptics.SequenceDefinitions.effects)
  return &effects_;
}
const ::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::Effect >&
SequenceDefinitions::effects() const {
  // @@protoc_insertion_point(field_list:NullSpaceHaptics.SequenceDefinitions.effects)
  return effects_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PatternDefinitions::kPatternNodesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PatternDefinitions::PatternDefinitions()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.PatternDefinitions)
}

void PatternDefinitions::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

PatternDefinitions::PatternDefinitions(const PatternDefinitions& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.PatternDefinitions)
}

void PatternDefinitions::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

PatternDefinitions::~PatternDefinitions() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.PatternDefinitions)
  SharedDtor();
}

void PatternDefinitions::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PatternDefinitions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PatternDefinitions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PatternDefinitions_descriptor_;
}

const PatternDefinitions& PatternDefinitions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

PatternDefinitions* PatternDefinitions::default_instance_ = NULL;

PatternDefinitions* PatternDefinitions::New(::google::protobuf::Arena* arena) const {
  PatternDefinitions* n = new PatternDefinitions;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PatternDefinitions::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.PatternDefinitions)
  pattern_nodes_.Clear();
}

bool PatternDefinitions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.PatternDefinitions)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .NullSpaceHaptics.PatternNode pattern_nodes = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_pattern_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_pattern_nodes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_pattern_nodes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.PatternDefinitions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.PatternDefinitions)
  return false;
#undef DO_
}

void PatternDefinitions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.PatternDefinitions)
  // repeated .NullSpaceHaptics.PatternNode pattern_nodes = 1;
  for (unsigned int i = 0, n = this->pattern_nodes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pattern_nodes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.PatternDefinitions)
}

::google::protobuf::uint8* PatternDefinitions::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.PatternDefinitions)
  // repeated .NullSpaceHaptics.PatternNode pattern_nodes = 1;
  for (unsigned int i = 0, n = this->pattern_nodes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->pattern_nodes(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.PatternDefinitions)
  return target;
}

int PatternDefinitions::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.PatternDefinitions)
  int total_size = 0;

  // repeated .NullSpaceHaptics.PatternNode pattern_nodes = 1;
  total_size += 1 * this->pattern_nodes_size();
  for (int i = 0; i < this->pattern_nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pattern_nodes(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PatternDefinitions::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.PatternDefinitions)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PatternDefinitions* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PatternDefinitions>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.PatternDefinitions)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.PatternDefinitions)
    MergeFrom(*source);
  }
}

void PatternDefinitions::MergeFrom(const PatternDefinitions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.PatternDefinitions)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  pattern_nodes_.MergeFrom(from.pattern_nodes_);
}

void PatternDefinitions::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.PatternDefinitions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PatternDefinitions::CopyFrom(const PatternDefinitions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.PatternDefinitions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PatternDefinitions::IsInitialized() const {

  return true;
}

void PatternDefinitions::Swap(PatternDefinitions* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PatternDefinitions::InternalSwap(PatternDefinitions* other) {
  pattern_nodes_.UnsafeArenaSwap(&other->pattern_nodes_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PatternDefinitions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PatternDefinitions_descriptor_;
  metadata.reflection = PatternDefinitions_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PatternDefinitions

// repeated .NullSpaceHaptics.PatternNode pattern_nodes = 1;
int PatternDefinitions::pattern_nodes_size() const {
  return pattern_nodes_.size();
}
void PatternDefinitions::clear_pattern_nodes() {
  pattern_nodes_.Clear();
}
const ::NullSpaceHaptics::PatternNode& PatternDefinitions::pattern_nodes(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.PatternDefinitions.pattern_nodes)
  return pattern_nodes_.Get(index);
}
::NullSpaceHaptics::PatternNode* PatternDefinitions::mutable_pattern_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.PatternDefinitions.pattern_nodes)
  return pattern_nodes_.Mutable(index);
}
::NullSpaceHaptics::PatternNode* PatternDefinitions::add_pattern_nodes() {
  // @@protoc_insertion_point(field_add:NullSpaceHaptics.PatternDefinitions.pattern_nodes)
  return pattern_nodes_.Add();
}
::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::PatternNode >*
PatternDefinitions::mutable_pattern_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceHaptics.PatternDefinitions.pattern_nodes)
  return &pattern_nodes_;
}
const ::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::PatternNode >&
PatternDefinitions::pattern_nodes() const {
  // @@protoc_insertion_point(field_list:NullSpaceHaptics.PatternDefinitions.pattern_nodes)
  return pattern_nodes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExperienceDefinitions::kExperienceNodesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExperienceDefinitions::ExperienceDefinitions()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.ExperienceDefinitions)
}

void ExperienceDefinitions::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ExperienceDefinitions::ExperienceDefinitions(const ExperienceDefinitions& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.ExperienceDefinitions)
}

void ExperienceDefinitions::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

ExperienceDefinitions::~ExperienceDefinitions() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.ExperienceDefinitions)
  SharedDtor();
}

void ExperienceDefinitions::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ExperienceDefinitions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExperienceDefinitions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExperienceDefinitions_descriptor_;
}

const ExperienceDefinitions& ExperienceDefinitions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

ExperienceDefinitions* ExperienceDefinitions::default_instance_ = NULL;

ExperienceDefinitions* ExperienceDefinitions::New(::google::protobuf::Arena* arena) const {
  ExperienceDefinitions* n = new ExperienceDefinitions;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ExperienceDefinitions::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.ExperienceDefinitions)
  experience_nodes_.Clear();
}

bool ExperienceDefinitions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.ExperienceDefinitions)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .NullSpaceHaptics.ExperienceNode experience_nodes = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_experience_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_experience_nodes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_experience_nodes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.ExperienceDefinitions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.ExperienceDefinitions)
  return false;
#undef DO_
}

void ExperienceDefinitions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.ExperienceDefinitions)
  // repeated .NullSpaceHaptics.ExperienceNode experience_nodes = 1;
  for (unsigned int i = 0, n = this->experience_nodes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->experience_nodes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.ExperienceDefinitions)
}

::google::protobuf::uint8* ExperienceDefinitions::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.ExperienceDefinitions)
  // repeated .NullSpaceHaptics.ExperienceNode experience_nodes = 1;
  for (unsigned int i = 0, n = this->experience_nodes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->experience_nodes(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.ExperienceDefinitions)
  return target;
}

int ExperienceDefinitions::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.ExperienceDefinitions)
  int total_size = 0;

  // repeated .NullSpaceHaptics.ExperienceNode experience_nodes = 1;
  total_size += 1 * this->experience_nodes_size();
  for (int i = 0; i < this->experience_nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->experience_nodes(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExperienceDefinitions::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.ExperienceDefinitions)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ExperienceDefinitions* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ExperienceDefinitions>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.ExperienceDefinitions)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.ExperienceDefinitions)
    MergeFrom(*source);
  }
}

void ExperienceDefinitions::MergeFrom(const ExperienceDefinitions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.ExperienceDefinitions)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  experience_nodes_.MergeFrom(from.experience_nodes_);
}

void ExperienceDefinitions::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.ExperienceDefinitions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExperienceDefinitions::CopyFrom(const ExperienceDefinitions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.ExperienceDefinitions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExperienceDefinitions::IsInitialized() const {

  return true;
}

void ExperienceDefinitions::Swap(ExperienceDefinitions* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExperienceDefinitions::InternalSwap(ExperienceDefinitions* other) {
  experience_nodes_.UnsafeArenaSwap(&other->experience_nodes_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ExperienceDefinitions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExperienceDefinitions_descriptor_;
  metadata.reflection = ExperienceDefinitions_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ExperienceDefinitions

// repeated .NullSpaceHaptics.ExperienceNode experience_nodes = 1;
int ExperienceDefinitions::experience_nodes_size() const {
  return experience_nodes_.size();
}
void ExperienceDefinitions::clear_experience_nodes() {
  experience_nodes_.Clear();
}
const ::NullSpaceHaptics::ExperienceNode& ExperienceDefinitions::experience_nodes(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.ExperienceDefinitions.experience_nodes)
  return experience_nodes_.Get(index);
}
::NullSpaceHaptics::ExperienceNode* ExperienceDefinitions::mutable_experience_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.ExperienceDefinitions.experience_nodes)
  return experience_nodes_.Mutable(index);
}
::NullSpaceHaptics::ExperienceNode* ExperienceDefinitions::add_experience_nodes() {
  // @@protoc_insertion_point(field_add:NullSpaceHaptics.ExperienceDefinitions.experience_nodes)
  return experience_nodes_.Add();
}
::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::ExperienceNode >*
ExperienceDefinitions::mutable_experience_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceHaptics.ExperienceDefinitions.experience_nodes)
  return &experience_nodes_;
}
const ::google::protobuf::RepeatedPtrField< ::NullSpaceHaptics::ExperienceNode >&
ExperienceDefinitions::experience_nodes() const {
  // @@protoc_insertion_point(field_list:NullSpaceHaptics.ExperienceDefinitions.experience_nodes)
  return experience_nodes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HapticDescriptionFile::kEffectFieldNumber;
const int HapticDescriptionFile::kSequenceDefinitionsFieldNumber;
const int HapticDescriptionFile::kPatternDefinitionsFieldNumber;
const int HapticDescriptionFile::kExperienceDefinitionsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HapticDescriptionFile::HapticDescriptionFile()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NullSpaceHaptics.HapticDescriptionFile)
}

void HapticDescriptionFile::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  effect_ = const_cast< ::NullSpaceHaptics::RootEffect*>(&::NullSpaceHaptics::RootEffect::default_instance());
}

HapticDescriptionFile::HapticDescriptionFile(const HapticDescriptionFile& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NullSpaceHaptics.HapticDescriptionFile)
}

void HapticDescriptionFile::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  effect_ = NULL;
  sequence_definitions_.SetAssignDescriptorCallback(
      protobuf_AssignDescriptorsOnce);
  sequence_definitions_.SetEntryDescriptor(
      &::NullSpaceHaptics::HapticDescriptionFile_SequenceDefinitionsEntry_descriptor_);
  pattern_definitions_.SetAssignDescriptorCallback(
      protobuf_AssignDescriptorsOnce);
  pattern_definitions_.SetEntryDescriptor(
      &::NullSpaceHaptics::HapticDescriptionFile_PatternDefinitionsEntry_descriptor_);
  experience_definitions_.SetAssignDescriptorCallback(
      protobuf_AssignDescriptorsOnce);
  experience_definitions_.SetEntryDescriptor(
      &::NullSpaceHaptics::HapticDescriptionFile_ExperienceDefinitionsEntry_descriptor_);
}

HapticDescriptionFile::~HapticDescriptionFile() {
  // @@protoc_insertion_point(destructor:NullSpaceHaptics.HapticDescriptionFile)
  SharedDtor();
}

void HapticDescriptionFile::SharedDtor() {
  if (this != default_instance_) {
    delete effect_;
  }
}

void HapticDescriptionFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HapticDescriptionFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HapticDescriptionFile_descriptor_;
}

const HapticDescriptionFile& HapticDescriptionFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_HapticEffect_2eproto();
  return *default_instance_;
}

HapticDescriptionFile* HapticDescriptionFile::default_instance_ = NULL;

HapticDescriptionFile* HapticDescriptionFile::New(::google::protobuf::Arena* arena) const {
  HapticDescriptionFile* n = new HapticDescriptionFile;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HapticDescriptionFile::Clear() {
// @@protoc_insertion_point(message_clear_start:NullSpaceHaptics.HapticDescriptionFile)
  if (GetArenaNoVirtual() == NULL && effect_ != NULL) delete effect_;
  effect_ = NULL;
  sequence_definitions_.Clear();
  pattern_definitions_.Clear();
  experience_definitions_.Clear();
}

bool HapticDescriptionFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NullSpaceHaptics.HapticDescriptionFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .NullSpaceHaptics.RootEffect effect = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_effect()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sequence_definitions;
        break;
      }

      // map<string, .NullSpaceHaptics.SequenceDefinitions> sequence_definitions = 2;
      case 2: {
        if (tag == 18) {
         parse_sequence_definitions:
          DO_(input->IncrementRecursionDepth());
         parse_loop_sequence_definitions:
          HapticDescriptionFile_SequenceDefinitionsEntry::Parser< ::google::protobuf::internal::MapField<
              ::std::string, ::NullSpaceHaptics::SequenceDefinitions,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
              0 >,
            ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions > > parser(&sequence_definitions_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "NullSpaceHaptics.HapticDescriptionFile.SequenceDefinitionsEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_sequence_definitions;
        if (input->ExpectTag(26)) goto parse_loop_pattern_definitions;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // map<string, .NullSpaceHaptics.PatternDefinitions> pattern_definitions = 3;
      case 3: {
        if (tag == 26) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_pattern_definitions:
          HapticDescriptionFile_PatternDefinitionsEntry::Parser< ::google::protobuf::internal::MapField<
              ::std::string, ::NullSpaceHaptics::PatternDefinitions,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
              0 >,
            ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions > > parser(&pattern_definitions_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "NullSpaceHaptics.HapticDescriptionFile.PatternDefinitionsEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_pattern_definitions;
        if (input->ExpectTag(34)) goto parse_loop_experience_definitions;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // map<string, .NullSpaceHaptics.ExperienceDefinitions> experience_definitions = 4;
      case 4: {
        if (tag == 34) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_experience_definitions:
          HapticDescriptionFile_ExperienceDefinitionsEntry::Parser< ::google::protobuf::internal::MapField<
              ::std::string, ::NullSpaceHaptics::ExperienceDefinitions,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
              0 >,
            ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions > > parser(&experience_definitions_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "NullSpaceHaptics.HapticDescriptionFile.ExperienceDefinitionsEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_experience_definitions;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NullSpaceHaptics.HapticDescriptionFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NullSpaceHaptics.HapticDescriptionFile)
  return false;
#undef DO_
}

void HapticDescriptionFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NullSpaceHaptics.HapticDescriptionFile)
  // optional .NullSpaceHaptics.RootEffect effect = 1;
  if (this->has_effect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->effect_, output);
  }

  // map<string, .NullSpaceHaptics.SequenceDefinitions> sequence_definitions = 2;
  if (!this->sequence_definitions().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "NullSpaceHaptics.HapticDescriptionFile.SequenceDefinitionsEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->sequence_definitions().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->sequence_definitions().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::const_iterator
          it = this->sequence_definitions().begin();
          it != this->sequence_definitions().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_SequenceDefinitionsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(sequence_definitions_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            2, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_SequenceDefinitionsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::const_iterator
          it = this->sequence_definitions().begin();
          it != this->sequence_definitions().end(); ++it) {
        entry.reset(sequence_definitions_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            2, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // map<string, .NullSpaceHaptics.PatternDefinitions> pattern_definitions = 3;
  if (!this->pattern_definitions().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "NullSpaceHaptics.HapticDescriptionFile.PatternDefinitionsEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->pattern_definitions().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->pattern_definitions().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::const_iterator
          it = this->pattern_definitions().begin();
          it != this->pattern_definitions().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_PatternDefinitionsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(pattern_definitions_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            3, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_PatternDefinitionsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::const_iterator
          it = this->pattern_definitions().begin();
          it != this->pattern_definitions().end(); ++it) {
        entry.reset(pattern_definitions_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            3, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // map<string, .NullSpaceHaptics.ExperienceDefinitions> experience_definitions = 4;
  if (!this->experience_definitions().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "NullSpaceHaptics.HapticDescriptionFile.ExperienceDefinitionsEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->experience_definitions().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->experience_definitions().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::const_iterator
          it = this->experience_definitions().begin();
          it != this->experience_definitions().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_ExperienceDefinitionsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(experience_definitions_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            4, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_ExperienceDefinitionsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::const_iterator
          it = this->experience_definitions().begin();
          it != this->experience_definitions().end(); ++it) {
        entry.reset(experience_definitions_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            4, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:NullSpaceHaptics.HapticDescriptionFile)
}

::google::protobuf::uint8* HapticDescriptionFile::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NullSpaceHaptics.HapticDescriptionFile)
  // optional .NullSpaceHaptics.RootEffect effect = 1;
  if (this->has_effect()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->effect_, false, target);
  }

  // map<string, .NullSpaceHaptics.SequenceDefinitions> sequence_definitions = 2;
  if (!this->sequence_definitions().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "NullSpaceHaptics.HapticDescriptionFile.SequenceDefinitionsEntry.key");
      }
    };

    if (deterministic &&
        this->sequence_definitions().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->sequence_definitions().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::const_iterator
          it = this->sequence_definitions().begin();
          it != this->sequence_definitions().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_SequenceDefinitionsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(sequence_definitions_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       2, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_SequenceDefinitionsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::const_iterator
          it = this->sequence_definitions().begin();
          it != this->sequence_definitions().end(); ++it) {
        entry.reset(sequence_definitions_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       2, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // map<string, .NullSpaceHaptics.PatternDefinitions> pattern_definitions = 3;
  if (!this->pattern_definitions().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "NullSpaceHaptics.HapticDescriptionFile.PatternDefinitionsEntry.key");
      }
    };

    if (deterministic &&
        this->pattern_definitions().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->pattern_definitions().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::const_iterator
          it = this->pattern_definitions().begin();
          it != this->pattern_definitions().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_PatternDefinitionsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(pattern_definitions_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       3, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_PatternDefinitionsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::const_iterator
          it = this->pattern_definitions().begin();
          it != this->pattern_definitions().end(); ++it) {
        entry.reset(pattern_definitions_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       3, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // map<string, .NullSpaceHaptics.ExperienceDefinitions> experience_definitions = 4;
  if (!this->experience_definitions().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "NullSpaceHaptics.HapticDescriptionFile.ExperienceDefinitionsEntry.key");
      }
    };

    if (deterministic &&
        this->experience_definitions().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->experience_definitions().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::const_iterator
          it = this->experience_definitions().begin();
          it != this->experience_definitions().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_ExperienceDefinitionsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(experience_definitions_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       4, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<HapticDescriptionFile_ExperienceDefinitionsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::const_iterator
          it = this->experience_definitions().begin();
          it != this->experience_definitions().end(); ++it) {
        entry.reset(experience_definitions_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       4, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_to_array_end:NullSpaceHaptics.HapticDescriptionFile)
  return target;
}

int HapticDescriptionFile::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NullSpaceHaptics.HapticDescriptionFile)
  int total_size = 0;

  // optional .NullSpaceHaptics.RootEffect effect = 1;
  if (this->has_effect()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->effect_);
  }

  // map<string, .NullSpaceHaptics.SequenceDefinitions> sequence_definitions = 2;
  total_size += 1 * this->sequence_definitions_size();
  {
    ::google::protobuf::scoped_ptr<HapticDescriptionFile_SequenceDefinitionsEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >::const_iterator
        it = this->sequence_definitions().begin();
        it != this->sequence_definitions().end(); ++it) {
      entry.reset(sequence_definitions_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  // map<string, .NullSpaceHaptics.PatternDefinitions> pattern_definitions = 3;
  total_size += 1 * this->pattern_definitions_size();
  {
    ::google::protobuf::scoped_ptr<HapticDescriptionFile_PatternDefinitionsEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >::const_iterator
        it = this->pattern_definitions().begin();
        it != this->pattern_definitions().end(); ++it) {
      entry.reset(pattern_definitions_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  // map<string, .NullSpaceHaptics.ExperienceDefinitions> experience_definitions = 4;
  total_size += 1 * this->experience_definitions_size();
  {
    ::google::protobuf::scoped_ptr<HapticDescriptionFile_ExperienceDefinitionsEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >::const_iterator
        it = this->experience_definitions().begin();
        it != this->experience_definitions().end(); ++it) {
      entry.reset(experience_definitions_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HapticDescriptionFile::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:NullSpaceHaptics.HapticDescriptionFile)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HapticDescriptionFile* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HapticDescriptionFile>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullSpaceHaptics.HapticDescriptionFile)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:NullSpaceHaptics.HapticDescriptionFile)
    MergeFrom(*source);
  }
}

void HapticDescriptionFile::MergeFrom(const HapticDescriptionFile& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NullSpaceHaptics.HapticDescriptionFile)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  sequence_definitions_.MergeFrom(from.sequence_definitions_);
  pattern_definitions_.MergeFrom(from.pattern_definitions_);
  experience_definitions_.MergeFrom(from.experience_definitions_);
  if (from.has_effect()) {
    mutable_effect()->::NullSpaceHaptics::RootEffect::MergeFrom(from.effect());
  }
}

void HapticDescriptionFile::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:NullSpaceHaptics.HapticDescriptionFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HapticDescriptionFile::CopyFrom(const HapticDescriptionFile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NullSpaceHaptics.HapticDescriptionFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HapticDescriptionFile::IsInitialized() const {

  return true;
}

void HapticDescriptionFile::Swap(HapticDescriptionFile* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HapticDescriptionFile::InternalSwap(HapticDescriptionFile* other) {
  std::swap(effect_, other->effect_);
  sequence_definitions_.Swap(&other->sequence_definitions_);
  pattern_definitions_.Swap(&other->pattern_definitions_);
  experience_definitions_.Swap(&other->experience_definitions_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HapticDescriptionFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HapticDescriptionFile_descriptor_;
  metadata.reflection = HapticDescriptionFile_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HapticDescriptionFile

// optional .NullSpaceHaptics.RootEffect effect = 1;
bool HapticDescriptionFile::has_effect() const {
  return !_is_default_instance_ && effect_ != NULL;
}
void HapticDescriptionFile::clear_effect() {
  if (GetArenaNoVirtual() == NULL && effect_ != NULL) delete effect_;
  effect_ = NULL;
}
const ::NullSpaceHaptics::RootEffect& HapticDescriptionFile::effect() const {
  // @@protoc_insertion_point(field_get:NullSpaceHaptics.HapticDescriptionFile.effect)
  return effect_ != NULL ? *effect_ : *default_instance_->effect_;
}
::NullSpaceHaptics::RootEffect* HapticDescriptionFile::mutable_effect() {
  
  if (effect_ == NULL) {
    effect_ = new ::NullSpaceHaptics::RootEffect;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceHaptics.HapticDescriptionFile.effect)
  return effect_;
}
::NullSpaceHaptics::RootEffect* HapticDescriptionFile::release_effect() {
  // @@protoc_insertion_point(field_release:NullSpaceHaptics.HapticDescriptionFile.effect)
  
  ::NullSpaceHaptics::RootEffect* temp = effect_;
  effect_ = NULL;
  return temp;
}
void HapticDescriptionFile::set_allocated_effect(::NullSpaceHaptics::RootEffect* effect) {
  delete effect_;
  effect_ = effect;
  if (effect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceHaptics.HapticDescriptionFile.effect)
}

// map<string, .NullSpaceHaptics.SequenceDefinitions> sequence_definitions = 2;
int HapticDescriptionFile::sequence_definitions_size() const {
  return sequence_definitions_.size();
}
void HapticDescriptionFile::clear_sequence_definitions() {
  sequence_definitions_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >&
HapticDescriptionFile::sequence_definitions() const {
  // @@protoc_insertion_point(field_map:NullSpaceHaptics.HapticDescriptionFile.sequence_definitions)
  return sequence_definitions_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::SequenceDefinitions >*
HapticDescriptionFile::mutable_sequence_definitions() {
  // @@protoc_insertion_point(field_mutable_map:NullSpaceHaptics.HapticDescriptionFile.sequence_definitions)
  return sequence_definitions_.MutableMap();
}

// map<string, .NullSpaceHaptics.PatternDefinitions> pattern_definitions = 3;
int HapticDescriptionFile::pattern_definitions_size() const {
  return pattern_definitions_.size();
}
void HapticDescriptionFile::clear_pattern_definitions() {
  pattern_definitions_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >&
HapticDescriptionFile::pattern_definitions() const {
  // @@protoc_insertion_point(field_map:NullSpaceHaptics.HapticDescriptionFile.pattern_definitions)
  return pattern_definitions_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::PatternDefinitions >*
HapticDescriptionFile::mutable_pattern_definitions() {
  // @@protoc_insertion_point(field_mutable_map:NullSpaceHaptics.HapticDescriptionFile.pattern_definitions)
  return pattern_definitions_.MutableMap();
}

// map<string, .NullSpaceHaptics.ExperienceDefinitions> experience_definitions = 4;
int HapticDescriptionFile::experience_definitions_size() const {
  return experience_definitions_.size();
}
void HapticDescriptionFile::clear_experience_definitions() {
  experience_definitions_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >&
HapticDescriptionFile::experience_definitions() const {
  // @@protoc_insertion_point(field_map:NullSpaceHaptics.HapticDescriptionFile.experience_definitions)
  return experience_definitions_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::NullSpaceHaptics::ExperienceDefinitions >*
HapticDescriptionFile::mutable_experience_definitions() {
  // @@protoc_insertion_point(field_mutable_map:NullSpaceHaptics.HapticDescriptionFile.experience_definitions)
  return experience_definitions_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace NullSpaceHaptics

// @@protoc_insertion_point(global_scope)
