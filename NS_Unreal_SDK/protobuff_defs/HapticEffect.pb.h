// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HapticEffect.proto

#ifndef PROTOBUF_HapticEffect_2eproto__INCLUDED
#define PROTOBUF_HapticEffect_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace nsvr {
namespace detail {
namespace encoding {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_HapticEffect_2eproto();
void protobuf_AssignDesc_HapticEffect_2eproto();
void protobuf_ShutdownFile_HapticEffect_2eproto();

class Effect;
class Experience;
class ExperienceDefinitions;
class ExperienceNode;
class HapticDescriptionFile;
class HapticFile;
class Pattern;
class PatternDefinitions;
class PatternNode;
class RootEffect;
class Sequence;
class SequenceDefinitions;

enum HapticFile_Type {
  HapticFile_Type_UNKNOWN = 0,
  HapticFile_Type_SEQUENCE = 1,
  HapticFile_Type_PATTERN = 2,
  HapticFile_Type_EXPERIENCE = 3,
  HapticFile_Type_HapticFile_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HapticFile_Type_HapticFile_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HapticFile_Type_IsValid(int value);
const HapticFile_Type HapticFile_Type_Type_MIN = HapticFile_Type_UNKNOWN;
const HapticFile_Type HapticFile_Type_Type_MAX = HapticFile_Type_EXPERIENCE;
const int HapticFile_Type_Type_ARRAYSIZE = HapticFile_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* HapticFile_Type_descriptor();
inline const ::std::string& HapticFile_Type_Name(HapticFile_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    HapticFile_Type_descriptor(), value);
}
inline bool HapticFile_Type_Parse(
    const ::std::string& name, HapticFile_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HapticFile_Type>(
    HapticFile_Type_descriptor(), name, value);
}
enum RootEffect_Type {
  RootEffect_Type_UNKNOWN = 0,
  RootEffect_Type_SEQUENCE = 1,
  RootEffect_Type_PATTERN = 2,
  RootEffect_Type_EXPERIENCE = 3,
  RootEffect_Type_RootEffect_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RootEffect_Type_RootEffect_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RootEffect_Type_IsValid(int value);
const RootEffect_Type RootEffect_Type_Type_MIN = RootEffect_Type_UNKNOWN;
const RootEffect_Type RootEffect_Type_Type_MAX = RootEffect_Type_EXPERIENCE;
const int RootEffect_Type_Type_ARRAYSIZE = RootEffect_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RootEffect_Type_descriptor();
inline const ::std::string& RootEffect_Type_Name(RootEffect_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RootEffect_Type_descriptor(), value);
}
inline bool RootEffect_Type_Parse(
    const ::std::string& name, RootEffect_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RootEffect_Type>(
    RootEffect_Type_descriptor(), name, value);
}
// ===================================================================

class Effect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.Effect) */ {
 public:
  Effect();
  virtual ~Effect();

  Effect(const Effect& from);

  inline Effect& operator=(const Effect& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Effect& default_instance();

  void Swap(Effect* other);

  // implements Message ----------------------------------------------

  inline Effect* New() const { return New(NULL); }

  Effect* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Effect& from);
  void MergeFrom(const Effect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Effect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  float time() const;
  void set_time(float value);

  // optional string effect = 2;
  void clear_effect();
  static const int kEffectFieldNumber = 2;
  const ::std::string& effect() const;
  void set_effect(const ::std::string& value);
  void set_effect(const char* value);
  void set_effect(const char* value, size_t size);
  ::std::string* mutable_effect();
  ::std::string* release_effect();
  void set_allocated_effect(::std::string* effect);

  // optional float strength = 3;
  void clear_strength();
  static const int kStrengthFieldNumber = 3;
  float strength() const;
  void set_strength(float value);

  // optional float duration = 4;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.Effect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr effect_;
  float time_;
  float strength_;
  float duration_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static Effect* default_instance_;
};
// -------------------------------------------------------------------

class Sequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.Sequence) */ {
 public:
  Sequence();
  virtual ~Sequence();

  Sequence(const Sequence& from);

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sequence& default_instance();

  void Swap(Sequence* other);

  // implements Message ----------------------------------------------

  inline Sequence* New() const { return New(NULL); }

  Sequence* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sequence& from);
  void MergeFrom(const Sequence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsvr.detail.encoding.Effect effects = 1;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 1;
  const ::nsvr::detail::encoding::Effect& effects(int index) const;
  ::nsvr::detail::encoding::Effect* mutable_effects(int index);
  ::nsvr::detail::encoding::Effect* add_effects();
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >*
      mutable_effects();
  const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >&
      effects() const;

  // optional float time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  float time() const;
  void set_time(float value);

  // optional float strength = 3;
  void clear_strength();
  static const int kStrengthFieldNumber = 3;
  float strength() const;
  void set_strength(float value);

  // optional uint32 area = 4;
  void clear_area();
  static const int kAreaFieldNumber = 4;
  ::google::protobuf::uint32 area() const;
  void set_area(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.Sequence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect > effects_;
  float time_;
  float strength_;
  ::google::protobuf::uint32 area_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static Sequence* default_instance_;
};
// -------------------------------------------------------------------

class Pattern : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.Pattern) */ {
 public:
  Pattern();
  virtual ~Pattern();

  Pattern(const Pattern& from);

  inline Pattern& operator=(const Pattern& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pattern& default_instance();

  void Swap(Pattern* other);

  // implements Message ----------------------------------------------

  inline Pattern* New() const { return New(NULL); }

  Pattern* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pattern& from);
  void MergeFrom(const Pattern& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pattern* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsvr.detail.encoding.Sequence sequences = 1;
  int sequences_size() const;
  void clear_sequences();
  static const int kSequencesFieldNumber = 1;
  const ::nsvr::detail::encoding::Sequence& sequences(int index) const;
  ::nsvr::detail::encoding::Sequence* mutable_sequences(int index);
  ::nsvr::detail::encoding::Sequence* add_sequences();
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Sequence >*
      mutable_sequences();
  const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Sequence >&
      sequences() const;

  // optional float time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  float time() const;
  void set_time(float value);

  // optional float strength = 3;
  void clear_strength();
  static const int kStrengthFieldNumber = 3;
  float strength() const;
  void set_strength(float value);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.Pattern)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Sequence > sequences_;
  float time_;
  float strength_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static Pattern* default_instance_;
};
// -------------------------------------------------------------------

class Experience : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.Experience) */ {
 public:
  Experience();
  virtual ~Experience();

  Experience(const Experience& from);

  inline Experience& operator=(const Experience& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Experience& default_instance();

  void Swap(Experience* other);

  // implements Message ----------------------------------------------

  inline Experience* New() const { return New(NULL); }

  Experience* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Experience& from);
  void MergeFrom(const Experience& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Experience* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsvr.detail.encoding.Pattern patterns = 1;
  int patterns_size() const;
  void clear_patterns();
  static const int kPatternsFieldNumber = 1;
  const ::nsvr::detail::encoding::Pattern& patterns(int index) const;
  ::nsvr::detail::encoding::Pattern* mutable_patterns(int index);
  ::nsvr::detail::encoding::Pattern* add_patterns();
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Pattern >*
      mutable_patterns();
  const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Pattern >&
      patterns() const;

  // optional float time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  float time() const;
  void set_time(float value);

  // optional float strength = 3;
  void clear_strength();
  static const int kStrengthFieldNumber = 3;
  float strength() const;
  void set_strength(float value);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.Experience)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Pattern > patterns_;
  float time_;
  float strength_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static Experience* default_instance_;
};
// -------------------------------------------------------------------

class HapticFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.HapticFile) */ {
 public:
  HapticFile();
  virtual ~HapticFile();

  HapticFile(const HapticFile& from);

  inline HapticFile& operator=(const HapticFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HapticFile& default_instance();

  void Swap(HapticFile* other);

  // implements Message ----------------------------------------------

  inline HapticFile* New() const { return New(NULL); }

  HapticFile* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HapticFile& from);
  void MergeFrom(const HapticFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HapticFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HapticFile_Type Type;
  static const Type UNKNOWN =
    HapticFile_Type_UNKNOWN;
  static const Type SEQUENCE =
    HapticFile_Type_SEQUENCE;
  static const Type PATTERN =
    HapticFile_Type_PATTERN;
  static const Type EXPERIENCE =
    HapticFile_Type_EXPERIENCE;
  static inline bool Type_IsValid(int value) {
    return HapticFile_Type_IsValid(value);
  }
  static const Type Type_MIN =
    HapticFile_Type_Type_MIN;
  static const Type Type_MAX =
    HapticFile_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    HapticFile_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return HapticFile_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return HapticFile_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return HapticFile_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .nsvr.detail.encoding.HapticFile.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::nsvr::detail::encoding::HapticFile_Type type() const;
  void set_type(::nsvr::detail::encoding::HapticFile_Type value);

  // optional .nsvr.detail.encoding.Sequence sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  const ::nsvr::detail::encoding::Sequence& sequence() const;
  ::nsvr::detail::encoding::Sequence* mutable_sequence();
  ::nsvr::detail::encoding::Sequence* release_sequence();
  void set_allocated_sequence(::nsvr::detail::encoding::Sequence* sequence);

  // optional .nsvr.detail.encoding.Pattern pattern = 3;
  bool has_pattern() const;
  void clear_pattern();
  static const int kPatternFieldNumber = 3;
  const ::nsvr::detail::encoding::Pattern& pattern() const;
  ::nsvr::detail::encoding::Pattern* mutable_pattern();
  ::nsvr::detail::encoding::Pattern* release_pattern();
  void set_allocated_pattern(::nsvr::detail::encoding::Pattern* pattern);

  // optional .nsvr.detail.encoding.Experience experience = 4;
  bool has_experience() const;
  void clear_experience();
  static const int kExperienceFieldNumber = 4;
  const ::nsvr::detail::encoding::Experience& experience() const;
  ::nsvr::detail::encoding::Experience* mutable_experience();
  ::nsvr::detail::encoding::Experience* release_experience();
  void set_allocated_experience(::nsvr::detail::encoding::Experience* experience);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.HapticFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::nsvr::detail::encoding::Sequence* sequence_;
  ::nsvr::detail::encoding::Pattern* pattern_;
  ::nsvr::detail::encoding::Experience* experience_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static HapticFile* default_instance_;
};
// -------------------------------------------------------------------

class RootEffect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.RootEffect) */ {
 public:
  RootEffect();
  virtual ~RootEffect();

  RootEffect(const RootEffect& from);

  inline RootEffect& operator=(const RootEffect& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RootEffect& default_instance();

  void Swap(RootEffect* other);

  // implements Message ----------------------------------------------

  inline RootEffect* New() const { return New(NULL); }

  RootEffect* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RootEffect& from);
  void MergeFrom(const RootEffect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RootEffect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RootEffect_Type Type;
  static const Type UNKNOWN =
    RootEffect_Type_UNKNOWN;
  static const Type SEQUENCE =
    RootEffect_Type_SEQUENCE;
  static const Type PATTERN =
    RootEffect_Type_PATTERN;
  static const Type EXPERIENCE =
    RootEffect_Type_EXPERIENCE;
  static inline bool Type_IsValid(int value) {
    return RootEffect_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RootEffect_Type_Type_MIN;
  static const Type Type_MAX =
    RootEffect_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RootEffect_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RootEffect_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RootEffect_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RootEffect_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .nsvr.detail.encoding.RootEffect.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::nsvr::detail::encoding::RootEffect_Type type() const;
  void set_type(::nsvr::detail::encoding::RootEffect_Type value);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.RootEffect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static RootEffect* default_instance_;
};
// -------------------------------------------------------------------

class PatternNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.PatternNode) */ {
 public:
  PatternNode();
  virtual ~PatternNode();

  PatternNode(const PatternNode& from);

  inline PatternNode& operator=(const PatternNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatternNode& default_instance();

  void Swap(PatternNode* other);

  // implements Message ----------------------------------------------

  inline PatternNode* New() const { return New(NULL); }

  PatternNode* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatternNode& from);
  void MergeFrom(const PatternNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PatternNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  float time() const;
  void set_time(float value);

  // optional string sequence = 2;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional uint32 area = 3;
  void clear_area();
  static const int kAreaFieldNumber = 3;
  ::google::protobuf::uint32 area() const;
  void set_area(::google::protobuf::uint32 value);

  // optional float strength = 4;
  void clear_strength();
  static const int kStrengthFieldNumber = 4;
  float strength() const;
  void set_strength(float value);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.PatternNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  float time_;
  ::google::protobuf::uint32 area_;
  float strength_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static PatternNode* default_instance_;
};
// -------------------------------------------------------------------

class ExperienceNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.ExperienceNode) */ {
 public:
  ExperienceNode();
  virtual ~ExperienceNode();

  ExperienceNode(const ExperienceNode& from);

  inline ExperienceNode& operator=(const ExperienceNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExperienceNode& default_instance();

  void Swap(ExperienceNode* other);

  // implements Message ----------------------------------------------

  inline ExperienceNode* New() const { return New(NULL); }

  ExperienceNode* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExperienceNode& from);
  void MergeFrom(const ExperienceNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExperienceNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  float time() const;
  void set_time(float value);

  // optional string pattern = 2;
  void clear_pattern();
  static const int kPatternFieldNumber = 2;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // optional float strength = 3;
  void clear_strength();
  static const int kStrengthFieldNumber = 3;
  float strength() const;
  void set_strength(float value);

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.ExperienceNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  float time_;
  float strength_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static ExperienceNode* default_instance_;
};
// -------------------------------------------------------------------

class SequenceDefinitions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.SequenceDefinitions) */ {
 public:
  SequenceDefinitions();
  virtual ~SequenceDefinitions();

  SequenceDefinitions(const SequenceDefinitions& from);

  inline SequenceDefinitions& operator=(const SequenceDefinitions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceDefinitions& default_instance();

  void Swap(SequenceDefinitions* other);

  // implements Message ----------------------------------------------

  inline SequenceDefinitions* New() const { return New(NULL); }

  SequenceDefinitions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SequenceDefinitions& from);
  void MergeFrom(const SequenceDefinitions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SequenceDefinitions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsvr.detail.encoding.Effect effects = 1;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 1;
  const ::nsvr::detail::encoding::Effect& effects(int index) const;
  ::nsvr::detail::encoding::Effect* mutable_effects(int index);
  ::nsvr::detail::encoding::Effect* add_effects();
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >*
      mutable_effects();
  const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >&
      effects() const;

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.SequenceDefinitions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect > effects_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static SequenceDefinitions* default_instance_;
};
// -------------------------------------------------------------------

class PatternDefinitions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.PatternDefinitions) */ {
 public:
  PatternDefinitions();
  virtual ~PatternDefinitions();

  PatternDefinitions(const PatternDefinitions& from);

  inline PatternDefinitions& operator=(const PatternDefinitions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatternDefinitions& default_instance();

  void Swap(PatternDefinitions* other);

  // implements Message ----------------------------------------------

  inline PatternDefinitions* New() const { return New(NULL); }

  PatternDefinitions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatternDefinitions& from);
  void MergeFrom(const PatternDefinitions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PatternDefinitions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsvr.detail.encoding.PatternNode pattern_nodes = 1;
  int pattern_nodes_size() const;
  void clear_pattern_nodes();
  static const int kPatternNodesFieldNumber = 1;
  const ::nsvr::detail::encoding::PatternNode& pattern_nodes(int index) const;
  ::nsvr::detail::encoding::PatternNode* mutable_pattern_nodes(int index);
  ::nsvr::detail::encoding::PatternNode* add_pattern_nodes();
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::PatternNode >*
      mutable_pattern_nodes();
  const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::PatternNode >&
      pattern_nodes() const;

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.PatternDefinitions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::PatternNode > pattern_nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static PatternDefinitions* default_instance_;
};
// -------------------------------------------------------------------

class ExperienceDefinitions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.ExperienceDefinitions) */ {
 public:
  ExperienceDefinitions();
  virtual ~ExperienceDefinitions();

  ExperienceDefinitions(const ExperienceDefinitions& from);

  inline ExperienceDefinitions& operator=(const ExperienceDefinitions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExperienceDefinitions& default_instance();

  void Swap(ExperienceDefinitions* other);

  // implements Message ----------------------------------------------

  inline ExperienceDefinitions* New() const { return New(NULL); }

  ExperienceDefinitions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExperienceDefinitions& from);
  void MergeFrom(const ExperienceDefinitions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExperienceDefinitions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsvr.detail.encoding.ExperienceNode experience_nodes = 1;
  int experience_nodes_size() const;
  void clear_experience_nodes();
  static const int kExperienceNodesFieldNumber = 1;
  const ::nsvr::detail::encoding::ExperienceNode& experience_nodes(int index) const;
  ::nsvr::detail::encoding::ExperienceNode* mutable_experience_nodes(int index);
  ::nsvr::detail::encoding::ExperienceNode* add_experience_nodes();
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::ExperienceNode >*
      mutable_experience_nodes();
  const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::ExperienceNode >&
      experience_nodes() const;

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.ExperienceDefinitions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::ExperienceNode > experience_nodes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static ExperienceDefinitions* default_instance_;
};
// -------------------------------------------------------------------

class HapticDescriptionFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nsvr.detail.encoding.HapticDescriptionFile) */ {
 public:
  HapticDescriptionFile();
  virtual ~HapticDescriptionFile();

  HapticDescriptionFile(const HapticDescriptionFile& from);

  inline HapticDescriptionFile& operator=(const HapticDescriptionFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HapticDescriptionFile& default_instance();

  void Swap(HapticDescriptionFile* other);

  // implements Message ----------------------------------------------

  inline HapticDescriptionFile* New() const { return New(NULL); }

  HapticDescriptionFile* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HapticDescriptionFile& from);
  void MergeFrom(const HapticDescriptionFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HapticDescriptionFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional .nsvr.detail.encoding.RootEffect effect = 1;
  bool has_effect() const;
  void clear_effect();
  static const int kEffectFieldNumber = 1;
  const ::nsvr::detail::encoding::RootEffect& effect() const;
  ::nsvr::detail::encoding::RootEffect* mutable_effect();
  ::nsvr::detail::encoding::RootEffect* release_effect();
  void set_allocated_effect(::nsvr::detail::encoding::RootEffect* effect);

  // map<string, .nsvr.detail.encoding.SequenceDefinitions> sequence_definitions = 2;
  int sequence_definitions_size() const;
  void clear_sequence_definitions();
  static const int kSequenceDefinitionsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::SequenceDefinitions >&
      sequence_definitions() const;
  ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::SequenceDefinitions >*
      mutable_sequence_definitions();

  // map<string, .nsvr.detail.encoding.PatternDefinitions> pattern_definitions = 3;
  int pattern_definitions_size() const;
  void clear_pattern_definitions();
  static const int kPatternDefinitionsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::PatternDefinitions >&
      pattern_definitions() const;
  ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::PatternDefinitions >*
      mutable_pattern_definitions();

  // map<string, .nsvr.detail.encoding.ExperienceDefinitions> experience_definitions = 4;
  int experience_definitions_size() const;
  void clear_experience_definitions();
  static const int kExperienceDefinitionsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::ExperienceDefinitions >&
      experience_definitions() const;
  ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::ExperienceDefinitions >*
      mutable_experience_definitions();

  // @@protoc_insertion_point(class_scope:nsvr.detail.encoding.HapticDescriptionFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::nsvr::detail::encoding::RootEffect* effect_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::nsvr::detail::encoding::SequenceDefinitions,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      HapticDescriptionFile_SequenceDefinitionsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::nsvr::detail::encoding::SequenceDefinitions,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > sequence_definitions_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::nsvr::detail::encoding::PatternDefinitions,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      HapticDescriptionFile_PatternDefinitionsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::nsvr::detail::encoding::PatternDefinitions,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > pattern_definitions_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::nsvr::detail::encoding::ExperienceDefinitions,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      HapticDescriptionFile_ExperienceDefinitionsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::nsvr::detail::encoding::ExperienceDefinitions,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > experience_definitions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HapticEffect_2eproto();
  friend void protobuf_AssignDesc_HapticEffect_2eproto();
  friend void protobuf_ShutdownFile_HapticEffect_2eproto();

  void InitAsDefaultInstance();
  static HapticDescriptionFile* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Effect

// optional float time = 1;
inline void Effect::clear_time() {
  time_ = 0;
}
inline float Effect::time() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Effect.time)
  return time_;
}
inline void Effect::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Effect.time)
}

// optional string effect = 2;
inline void Effect::clear_effect() {
  effect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Effect::effect() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Effect.effect)
  return effect_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Effect::set_effect(const ::std::string& value) {
  
  effect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Effect.effect)
}
inline void Effect::set_effect(const char* value) {
  
  effect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsvr.detail.encoding.Effect.effect)
}
inline void Effect::set_effect(const char* value, size_t size) {
  
  effect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsvr.detail.encoding.Effect.effect)
}
inline ::std::string* Effect::mutable_effect() {
  
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.Effect.effect)
  return effect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Effect::release_effect() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.Effect.effect)
  
  return effect_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Effect::set_allocated_effect(::std::string* effect) {
  if (effect != NULL) {
    
  } else {
    
  }
  effect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), effect);
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.Effect.effect)
}

// optional float strength = 3;
inline void Effect::clear_strength() {
  strength_ = 0;
}
inline float Effect::strength() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Effect.strength)
  return strength_;
}
inline void Effect::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Effect.strength)
}

// optional float duration = 4;
inline void Effect::clear_duration() {
  duration_ = 0;
}
inline float Effect::duration() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Effect.duration)
  return duration_;
}
inline void Effect::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Effect.duration)
}

// -------------------------------------------------------------------

// Sequence

// repeated .nsvr.detail.encoding.Effect effects = 1;
inline int Sequence::effects_size() const {
  return effects_.size();
}
inline void Sequence::clear_effects() {
  effects_.Clear();
}
inline const ::nsvr::detail::encoding::Effect& Sequence::effects(int index) const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Sequence.effects)
  return effects_.Get(index);
}
inline ::nsvr::detail::encoding::Effect* Sequence::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.Sequence.effects)
  return effects_.Mutable(index);
}
inline ::nsvr::detail::encoding::Effect* Sequence::add_effects() {
  // @@protoc_insertion_point(field_add:nsvr.detail.encoding.Sequence.effects)
  return effects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >*
Sequence::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:nsvr.detail.encoding.Sequence.effects)
  return &effects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >&
Sequence::effects() const {
  // @@protoc_insertion_point(field_list:nsvr.detail.encoding.Sequence.effects)
  return effects_;
}

// optional float time = 2;
inline void Sequence::clear_time() {
  time_ = 0;
}
inline float Sequence::time() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Sequence.time)
  return time_;
}
inline void Sequence::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Sequence.time)
}

// optional float strength = 3;
inline void Sequence::clear_strength() {
  strength_ = 0;
}
inline float Sequence::strength() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Sequence.strength)
  return strength_;
}
inline void Sequence::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Sequence.strength)
}

// optional uint32 area = 4;
inline void Sequence::clear_area() {
  area_ = 0u;
}
inline ::google::protobuf::uint32 Sequence::area() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Sequence.area)
  return area_;
}
inline void Sequence::set_area(::google::protobuf::uint32 value) {
  
  area_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Sequence.area)
}

// -------------------------------------------------------------------

// Pattern

// repeated .nsvr.detail.encoding.Sequence sequences = 1;
inline int Pattern::sequences_size() const {
  return sequences_.size();
}
inline void Pattern::clear_sequences() {
  sequences_.Clear();
}
inline const ::nsvr::detail::encoding::Sequence& Pattern::sequences(int index) const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Pattern.sequences)
  return sequences_.Get(index);
}
inline ::nsvr::detail::encoding::Sequence* Pattern::mutable_sequences(int index) {
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.Pattern.sequences)
  return sequences_.Mutable(index);
}
inline ::nsvr::detail::encoding::Sequence* Pattern::add_sequences() {
  // @@protoc_insertion_point(field_add:nsvr.detail.encoding.Pattern.sequences)
  return sequences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Sequence >*
Pattern::mutable_sequences() {
  // @@protoc_insertion_point(field_mutable_list:nsvr.detail.encoding.Pattern.sequences)
  return &sequences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Sequence >&
Pattern::sequences() const {
  // @@protoc_insertion_point(field_list:nsvr.detail.encoding.Pattern.sequences)
  return sequences_;
}

// optional float time = 2;
inline void Pattern::clear_time() {
  time_ = 0;
}
inline float Pattern::time() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Pattern.time)
  return time_;
}
inline void Pattern::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Pattern.time)
}

// optional float strength = 3;
inline void Pattern::clear_strength() {
  strength_ = 0;
}
inline float Pattern::strength() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Pattern.strength)
  return strength_;
}
inline void Pattern::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Pattern.strength)
}

// -------------------------------------------------------------------

// Experience

// repeated .nsvr.detail.encoding.Pattern patterns = 1;
inline int Experience::patterns_size() const {
  return patterns_.size();
}
inline void Experience::clear_patterns() {
  patterns_.Clear();
}
inline const ::nsvr::detail::encoding::Pattern& Experience::patterns(int index) const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Experience.patterns)
  return patterns_.Get(index);
}
inline ::nsvr::detail::encoding::Pattern* Experience::mutable_patterns(int index) {
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.Experience.patterns)
  return patterns_.Mutable(index);
}
inline ::nsvr::detail::encoding::Pattern* Experience::add_patterns() {
  // @@protoc_insertion_point(field_add:nsvr.detail.encoding.Experience.patterns)
  return patterns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Pattern >*
Experience::mutable_patterns() {
  // @@protoc_insertion_point(field_mutable_list:nsvr.detail.encoding.Experience.patterns)
  return &patterns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Pattern >&
Experience::patterns() const {
  // @@protoc_insertion_point(field_list:nsvr.detail.encoding.Experience.patterns)
  return patterns_;
}

// optional float time = 2;
inline void Experience::clear_time() {
  time_ = 0;
}
inline float Experience::time() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Experience.time)
  return time_;
}
inline void Experience::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Experience.time)
}

// optional float strength = 3;
inline void Experience::clear_strength() {
  strength_ = 0;
}
inline float Experience::strength() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.Experience.strength)
  return strength_;
}
inline void Experience::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.Experience.strength)
}

// -------------------------------------------------------------------

// HapticFile

// optional .nsvr.detail.encoding.HapticFile.Type type = 1;
inline void HapticFile::clear_type() {
  type_ = 0;
}
inline ::nsvr::detail::encoding::HapticFile_Type HapticFile::type() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.HapticFile.type)
  return static_cast< ::nsvr::detail::encoding::HapticFile_Type >(type_);
}
inline void HapticFile::set_type(::nsvr::detail::encoding::HapticFile_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.HapticFile.type)
}

// optional .nsvr.detail.encoding.Sequence sequence = 2;
inline bool HapticFile::has_sequence() const {
  return !_is_default_instance_ && sequence_ != NULL;
}
inline void HapticFile::clear_sequence() {
  if (GetArenaNoVirtual() == NULL && sequence_ != NULL) delete sequence_;
  sequence_ = NULL;
}
inline const ::nsvr::detail::encoding::Sequence& HapticFile::sequence() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.HapticFile.sequence)
  return sequence_ != NULL ? *sequence_ : *default_instance_->sequence_;
}
inline ::nsvr::detail::encoding::Sequence* HapticFile::mutable_sequence() {
  
  if (sequence_ == NULL) {
    sequence_ = new ::nsvr::detail::encoding::Sequence;
  }
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.HapticFile.sequence)
  return sequence_;
}
inline ::nsvr::detail::encoding::Sequence* HapticFile::release_sequence() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.HapticFile.sequence)
  
  ::nsvr::detail::encoding::Sequence* temp = sequence_;
  sequence_ = NULL;
  return temp;
}
inline void HapticFile::set_allocated_sequence(::nsvr::detail::encoding::Sequence* sequence) {
  delete sequence_;
  sequence_ = sequence;
  if (sequence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.HapticFile.sequence)
}

// optional .nsvr.detail.encoding.Pattern pattern = 3;
inline bool HapticFile::has_pattern() const {
  return !_is_default_instance_ && pattern_ != NULL;
}
inline void HapticFile::clear_pattern() {
  if (GetArenaNoVirtual() == NULL && pattern_ != NULL) delete pattern_;
  pattern_ = NULL;
}
inline const ::nsvr::detail::encoding::Pattern& HapticFile::pattern() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.HapticFile.pattern)
  return pattern_ != NULL ? *pattern_ : *default_instance_->pattern_;
}
inline ::nsvr::detail::encoding::Pattern* HapticFile::mutable_pattern() {
  
  if (pattern_ == NULL) {
    pattern_ = new ::nsvr::detail::encoding::Pattern;
  }
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.HapticFile.pattern)
  return pattern_;
}
inline ::nsvr::detail::encoding::Pattern* HapticFile::release_pattern() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.HapticFile.pattern)
  
  ::nsvr::detail::encoding::Pattern* temp = pattern_;
  pattern_ = NULL;
  return temp;
}
inline void HapticFile::set_allocated_pattern(::nsvr::detail::encoding::Pattern* pattern) {
  delete pattern_;
  pattern_ = pattern;
  if (pattern) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.HapticFile.pattern)
}

// optional .nsvr.detail.encoding.Experience experience = 4;
inline bool HapticFile::has_experience() const {
  return !_is_default_instance_ && experience_ != NULL;
}
inline void HapticFile::clear_experience() {
  if (GetArenaNoVirtual() == NULL && experience_ != NULL) delete experience_;
  experience_ = NULL;
}
inline const ::nsvr::detail::encoding::Experience& HapticFile::experience() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.HapticFile.experience)
  return experience_ != NULL ? *experience_ : *default_instance_->experience_;
}
inline ::nsvr::detail::encoding::Experience* HapticFile::mutable_experience() {
  
  if (experience_ == NULL) {
    experience_ = new ::nsvr::detail::encoding::Experience;
  }
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.HapticFile.experience)
  return experience_;
}
inline ::nsvr::detail::encoding::Experience* HapticFile::release_experience() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.HapticFile.experience)
  
  ::nsvr::detail::encoding::Experience* temp = experience_;
  experience_ = NULL;
  return temp;
}
inline void HapticFile::set_allocated_experience(::nsvr::detail::encoding::Experience* experience) {
  delete experience_;
  experience_ = experience;
  if (experience) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.HapticFile.experience)
}

// -------------------------------------------------------------------

// RootEffect

// optional string name = 1;
inline void RootEffect::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RootEffect::name() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.RootEffect.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RootEffect::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.RootEffect.name)
}
inline void RootEffect::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsvr.detail.encoding.RootEffect.name)
}
inline void RootEffect::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsvr.detail.encoding.RootEffect.name)
}
inline ::std::string* RootEffect::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.RootEffect.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RootEffect::release_name() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.RootEffect.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RootEffect::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.RootEffect.name)
}

// optional .nsvr.detail.encoding.RootEffect.Type type = 2;
inline void RootEffect::clear_type() {
  type_ = 0;
}
inline ::nsvr::detail::encoding::RootEffect_Type RootEffect::type() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.RootEffect.type)
  return static_cast< ::nsvr::detail::encoding::RootEffect_Type >(type_);
}
inline void RootEffect::set_type(::nsvr::detail::encoding::RootEffect_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.RootEffect.type)
}

// -------------------------------------------------------------------

// PatternNode

// optional float time = 1;
inline void PatternNode::clear_time() {
  time_ = 0;
}
inline float PatternNode::time() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.PatternNode.time)
  return time_;
}
inline void PatternNode::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.PatternNode.time)
}

// optional string sequence = 2;
inline void PatternNode::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PatternNode::sequence() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.PatternNode.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PatternNode::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.PatternNode.sequence)
}
inline void PatternNode::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsvr.detail.encoding.PatternNode.sequence)
}
inline void PatternNode::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsvr.detail.encoding.PatternNode.sequence)
}
inline ::std::string* PatternNode::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.PatternNode.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PatternNode::release_sequence() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.PatternNode.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PatternNode::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.PatternNode.sequence)
}

// optional uint32 area = 3;
inline void PatternNode::clear_area() {
  area_ = 0u;
}
inline ::google::protobuf::uint32 PatternNode::area() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.PatternNode.area)
  return area_;
}
inline void PatternNode::set_area(::google::protobuf::uint32 value) {
  
  area_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.PatternNode.area)
}

// optional float strength = 4;
inline void PatternNode::clear_strength() {
  strength_ = 0;
}
inline float PatternNode::strength() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.PatternNode.strength)
  return strength_;
}
inline void PatternNode::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.PatternNode.strength)
}

// -------------------------------------------------------------------

// ExperienceNode

// optional float time = 1;
inline void ExperienceNode::clear_time() {
  time_ = 0;
}
inline float ExperienceNode::time() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.ExperienceNode.time)
  return time_;
}
inline void ExperienceNode::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.ExperienceNode.time)
}

// optional string pattern = 2;
inline void ExperienceNode::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExperienceNode::pattern() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.ExperienceNode.pattern)
  return pattern_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExperienceNode::set_pattern(const ::std::string& value) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.ExperienceNode.pattern)
}
inline void ExperienceNode::set_pattern(const char* value) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nsvr.detail.encoding.ExperienceNode.pattern)
}
inline void ExperienceNode::set_pattern(const char* value, size_t size) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nsvr.detail.encoding.ExperienceNode.pattern)
}
inline ::std::string* ExperienceNode::mutable_pattern() {
  
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.ExperienceNode.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExperienceNode::release_pattern() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.ExperienceNode.pattern)
  
  return pattern_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExperienceNode::set_allocated_pattern(::std::string* pattern) {
  if (pattern != NULL) {
    
  } else {
    
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.ExperienceNode.pattern)
}

// optional float strength = 3;
inline void ExperienceNode::clear_strength() {
  strength_ = 0;
}
inline float ExperienceNode::strength() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.ExperienceNode.strength)
  return strength_;
}
inline void ExperienceNode::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:nsvr.detail.encoding.ExperienceNode.strength)
}

// -------------------------------------------------------------------

// SequenceDefinitions

// repeated .nsvr.detail.encoding.Effect effects = 1;
inline int SequenceDefinitions::effects_size() const {
  return effects_.size();
}
inline void SequenceDefinitions::clear_effects() {
  effects_.Clear();
}
inline const ::nsvr::detail::encoding::Effect& SequenceDefinitions::effects(int index) const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.SequenceDefinitions.effects)
  return effects_.Get(index);
}
inline ::nsvr::detail::encoding::Effect* SequenceDefinitions::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.SequenceDefinitions.effects)
  return effects_.Mutable(index);
}
inline ::nsvr::detail::encoding::Effect* SequenceDefinitions::add_effects() {
  // @@protoc_insertion_point(field_add:nsvr.detail.encoding.SequenceDefinitions.effects)
  return effects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >*
SequenceDefinitions::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:nsvr.detail.encoding.SequenceDefinitions.effects)
  return &effects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::Effect >&
SequenceDefinitions::effects() const {
  // @@protoc_insertion_point(field_list:nsvr.detail.encoding.SequenceDefinitions.effects)
  return effects_;
}

// -------------------------------------------------------------------

// PatternDefinitions

// repeated .nsvr.detail.encoding.PatternNode pattern_nodes = 1;
inline int PatternDefinitions::pattern_nodes_size() const {
  return pattern_nodes_.size();
}
inline void PatternDefinitions::clear_pattern_nodes() {
  pattern_nodes_.Clear();
}
inline const ::nsvr::detail::encoding::PatternNode& PatternDefinitions::pattern_nodes(int index) const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.PatternDefinitions.pattern_nodes)
  return pattern_nodes_.Get(index);
}
inline ::nsvr::detail::encoding::PatternNode* PatternDefinitions::mutable_pattern_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.PatternDefinitions.pattern_nodes)
  return pattern_nodes_.Mutable(index);
}
inline ::nsvr::detail::encoding::PatternNode* PatternDefinitions::add_pattern_nodes() {
  // @@protoc_insertion_point(field_add:nsvr.detail.encoding.PatternDefinitions.pattern_nodes)
  return pattern_nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::PatternNode >*
PatternDefinitions::mutable_pattern_nodes() {
  // @@protoc_insertion_point(field_mutable_list:nsvr.detail.encoding.PatternDefinitions.pattern_nodes)
  return &pattern_nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::PatternNode >&
PatternDefinitions::pattern_nodes() const {
  // @@protoc_insertion_point(field_list:nsvr.detail.encoding.PatternDefinitions.pattern_nodes)
  return pattern_nodes_;
}

// -------------------------------------------------------------------

// ExperienceDefinitions

// repeated .nsvr.detail.encoding.ExperienceNode experience_nodes = 1;
inline int ExperienceDefinitions::experience_nodes_size() const {
  return experience_nodes_.size();
}
inline void ExperienceDefinitions::clear_experience_nodes() {
  experience_nodes_.Clear();
}
inline const ::nsvr::detail::encoding::ExperienceNode& ExperienceDefinitions::experience_nodes(int index) const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.ExperienceDefinitions.experience_nodes)
  return experience_nodes_.Get(index);
}
inline ::nsvr::detail::encoding::ExperienceNode* ExperienceDefinitions::mutable_experience_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.ExperienceDefinitions.experience_nodes)
  return experience_nodes_.Mutable(index);
}
inline ::nsvr::detail::encoding::ExperienceNode* ExperienceDefinitions::add_experience_nodes() {
  // @@protoc_insertion_point(field_add:nsvr.detail.encoding.ExperienceDefinitions.experience_nodes)
  return experience_nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::ExperienceNode >*
ExperienceDefinitions::mutable_experience_nodes() {
  // @@protoc_insertion_point(field_mutable_list:nsvr.detail.encoding.ExperienceDefinitions.experience_nodes)
  return &experience_nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nsvr::detail::encoding::ExperienceNode >&
ExperienceDefinitions::experience_nodes() const {
  // @@protoc_insertion_point(field_list:nsvr.detail.encoding.ExperienceDefinitions.experience_nodes)
  return experience_nodes_;
}

// -------------------------------------------------------------------

// HapticDescriptionFile

// optional .nsvr.detail.encoding.RootEffect effect = 1;
inline bool HapticDescriptionFile::has_effect() const {
  return !_is_default_instance_ && effect_ != NULL;
}
inline void HapticDescriptionFile::clear_effect() {
  if (GetArenaNoVirtual() == NULL && effect_ != NULL) delete effect_;
  effect_ = NULL;
}
inline const ::nsvr::detail::encoding::RootEffect& HapticDescriptionFile::effect() const {
  // @@protoc_insertion_point(field_get:nsvr.detail.encoding.HapticDescriptionFile.effect)
  return effect_ != NULL ? *effect_ : *default_instance_->effect_;
}
inline ::nsvr::detail::encoding::RootEffect* HapticDescriptionFile::mutable_effect() {
  
  if (effect_ == NULL) {
    effect_ = new ::nsvr::detail::encoding::RootEffect;
  }
  // @@protoc_insertion_point(field_mutable:nsvr.detail.encoding.HapticDescriptionFile.effect)
  return effect_;
}
inline ::nsvr::detail::encoding::RootEffect* HapticDescriptionFile::release_effect() {
  // @@protoc_insertion_point(field_release:nsvr.detail.encoding.HapticDescriptionFile.effect)
  
  ::nsvr::detail::encoding::RootEffect* temp = effect_;
  effect_ = NULL;
  return temp;
}
inline void HapticDescriptionFile::set_allocated_effect(::nsvr::detail::encoding::RootEffect* effect) {
  delete effect_;
  effect_ = effect;
  if (effect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:nsvr.detail.encoding.HapticDescriptionFile.effect)
}

// map<string, .nsvr.detail.encoding.SequenceDefinitions> sequence_definitions = 2;
inline int HapticDescriptionFile::sequence_definitions_size() const {
  return sequence_definitions_.size();
}
inline void HapticDescriptionFile::clear_sequence_definitions() {
  sequence_definitions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::SequenceDefinitions >&
HapticDescriptionFile::sequence_definitions() const {
  // @@protoc_insertion_point(field_map:nsvr.detail.encoding.HapticDescriptionFile.sequence_definitions)
  return sequence_definitions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::SequenceDefinitions >*
HapticDescriptionFile::mutable_sequence_definitions() {
  // @@protoc_insertion_point(field_mutable_map:nsvr.detail.encoding.HapticDescriptionFile.sequence_definitions)
  return sequence_definitions_.MutableMap();
}

// map<string, .nsvr.detail.encoding.PatternDefinitions> pattern_definitions = 3;
inline int HapticDescriptionFile::pattern_definitions_size() const {
  return pattern_definitions_.size();
}
inline void HapticDescriptionFile::clear_pattern_definitions() {
  pattern_definitions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::PatternDefinitions >&
HapticDescriptionFile::pattern_definitions() const {
  // @@protoc_insertion_point(field_map:nsvr.detail.encoding.HapticDescriptionFile.pattern_definitions)
  return pattern_definitions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::PatternDefinitions >*
HapticDescriptionFile::mutable_pattern_definitions() {
  // @@protoc_insertion_point(field_mutable_map:nsvr.detail.encoding.HapticDescriptionFile.pattern_definitions)
  return pattern_definitions_.MutableMap();
}

// map<string, .nsvr.detail.encoding.ExperienceDefinitions> experience_definitions = 4;
inline int HapticDescriptionFile::experience_definitions_size() const {
  return experience_definitions_.size();
}
inline void HapticDescriptionFile::clear_experience_definitions() {
  experience_definitions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::ExperienceDefinitions >&
HapticDescriptionFile::experience_definitions() const {
  // @@protoc_insertion_point(field_map:nsvr.detail.encoding.HapticDescriptionFile.experience_definitions)
  return experience_definitions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::nsvr::detail::encoding::ExperienceDefinitions >*
HapticDescriptionFile::mutable_experience_definitions() {
  // @@protoc_insertion_point(field_mutable_map:nsvr.detail.encoding.HapticDescriptionFile.experience_definitions)
  return experience_definitions_.MutableMap();
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace encoding
}  // namespace detail
}  // namespace nsvr

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nsvr::detail::encoding::HapticFile_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsvr::detail::encoding::HapticFile_Type>() {
  return ::nsvr::detail::encoding::HapticFile_Type_descriptor();
}
template <> struct is_proto_enum< ::nsvr::detail::encoding::RootEffect_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsvr::detail::encoding::RootEffect_Type>() {
  return ::nsvr::detail::encoding::RootEffect_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HapticEffect_2eproto__INCLUDED
