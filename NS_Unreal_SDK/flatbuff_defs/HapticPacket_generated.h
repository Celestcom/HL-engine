// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_HAPTICPACKET_NULLSPACE_HAPTICFILES_H_
#define FLATBUFFERS_GENERATED_HAPTICPACKET_NULLSPACE_HAPTICFILES_H_

#include "flatbuffers/flatbuffers.h"

#include "Experience_generated.h"
#include "HapticEffect_generated.h"
#include "HapticFrame_generated.h"
#include "HapticSample_generated.h"
#include "Pattern_generated.h"
#include "Sequence_generated.h"

namespace NullSpace {
namespace HapticFiles {

struct HapticPacket;

enum FileType {
  FileType_NONE = 0,
  FileType_Experience = 1,
  FileType_Pattern = 2,
  FileType_Sequence = 3,
  FileType_MIN = FileType_NONE,
  FileType_MAX = FileType_Sequence
};

inline const char **EnumNamesFileType() {
  static const char *names[] = { "NONE", "Experience", "Pattern", "Sequence", nullptr };
  return names;
}

inline const char *EnumNameFileType(FileType e) { return EnumNamesFileType()[static_cast<int>(e)]; }

template<typename T> struct FileTypeTraits {
  static const FileType enum_value = FileType_NONE;
};

template<> struct FileTypeTraits<NullSpace::HapticFiles::Experience> {
  static const FileType enum_value = FileType_Experience;
};

template<> struct FileTypeTraits<NullSpace::HapticFiles::Pattern> {
  static const FileType enum_value = FileType_Pattern;
};

template<> struct FileTypeTraits<NullSpace::HapticFiles::Sequence> {
  static const FileType enum_value = FileType_Sequence;
};

inline bool VerifyFileType(flatbuffers::Verifier &verifier, const void *union_obj, FileType type);

struct HapticPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PACKET_TYPE = 6,
    VT_PACKET = 8
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  FileType packet_type() const { return static_cast<FileType>(GetField<uint8_t>(VT_PACKET_TYPE, 0)); }
  const void *packet() const { return GetPointer<const void *>(VT_PACKET); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PACKET) &&
           VerifyFileType(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

struct HapticPacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(HapticPacket::VT_NAME, name); }
  void add_packet_type(FileType packet_type) { fbb_.AddElement<uint8_t>(HapticPacket::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0); }
  void add_packet(flatbuffers::Offset<void> packet) { fbb_.AddOffset(HapticPacket::VT_PACKET, packet); }
  HapticPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  HapticPacketBuilder &operator=(const HapticPacketBuilder &);
  flatbuffers::Offset<HapticPacket> Finish() {
    auto o = flatbuffers::Offset<HapticPacket>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<HapticPacket> CreateHapticPacket(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    FileType packet_type = FileType_NONE,
    flatbuffers::Offset<void> packet = 0) {
  HapticPacketBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_name(name);
  builder_.add_packet_type(packet_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<HapticPacket> CreateHapticPacketDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    FileType packet_type = FileType_NONE,
    flatbuffers::Offset<void> packet = 0) {
  return CreateHapticPacket(_fbb, name ? _fbb.CreateString(name) : 0, packet_type, packet);
}

inline bool VerifyFileType(flatbuffers::Verifier &verifier, const void *union_obj, FileType type) {
  switch (type) {
    case FileType_NONE: return true;
    case FileType_Experience: return verifier.VerifyTable(reinterpret_cast<const NullSpace::HapticFiles::Experience *>(union_obj));
    case FileType_Pattern: return verifier.VerifyTable(reinterpret_cast<const NullSpace::HapticFiles::Pattern *>(union_obj));
    case FileType_Sequence: return verifier.VerifyTable(reinterpret_cast<const NullSpace::HapticFiles::Sequence *>(union_obj));
    default: return false;
  }
}

inline const NullSpace::HapticFiles::HapticPacket *GetHapticPacket(const void *buf) {
  return flatbuffers::GetRoot<NullSpace::HapticFiles::HapticPacket>(buf);
}

inline bool VerifyHapticPacketBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NullSpace::HapticFiles::HapticPacket>(nullptr);
}

inline void FinishHapticPacketBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<NullSpace::HapticFiles::HapticPacket> root) {
  fbb.Finish(root);
}

}  // namespace HapticFiles
}  // namespace NullSpace

#endif  // FLATBUFFERS_GENERATED_HAPTICPACKET_NULLSPACE_HAPTICFILES_H_
