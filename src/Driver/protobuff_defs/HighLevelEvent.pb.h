// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HighLevelEvent.proto

#ifndef PROTOBUF_HighLevelEvent_2eproto__INCLUDED
#define PROTOBUF_HighLevelEvent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace NullSpaceIPC {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_HighLevelEvent_2eproto();
void protobuf_AssignDesc_HighLevelEvent_2eproto();
void protobuf_ShutdownFile_HighLevelEvent_2eproto();

class BeginAnalogAudio;
class BufferedHaptic;
class ClientIdentificationEvent;
class ContinuousHaptic;
class DeviceEvent;
class DisableTracking;
class EnableTracking;
class EndAnalogAudio;
class HighLevelEvent;
class Location;
class LocationalEvent;
class NodeList;
class PlaybackEvent;
class RegionList;
class SimpleHaptic;

enum PlaybackEvent_Command {
  PlaybackEvent_Command_UNKNOWN = 0,
  PlaybackEvent_Command_PAUSE = 1,
  PlaybackEvent_Command_UNPAUSE = 2,
  PlaybackEvent_Command_CANCEL = 3,
  PlaybackEvent_Command_PlaybackEvent_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PlaybackEvent_Command_PlaybackEvent_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PlaybackEvent_Command_IsValid(int value);
const PlaybackEvent_Command PlaybackEvent_Command_Command_MIN = PlaybackEvent_Command_UNKNOWN;
const PlaybackEvent_Command PlaybackEvent_Command_Command_MAX = PlaybackEvent_Command_CANCEL;
const int PlaybackEvent_Command_Command_ARRAYSIZE = PlaybackEvent_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlaybackEvent_Command_descriptor();
inline const ::std::string& PlaybackEvent_Command_Name(PlaybackEvent_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlaybackEvent_Command_descriptor(), value);
}
inline bool PlaybackEvent_Command_Parse(
    const ::std::string& name, PlaybackEvent_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlaybackEvent_Command>(
    PlaybackEvent_Command_descriptor(), name, value);
}
// ===================================================================

class ClientIdentificationEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.ClientIdentificationEvent) */ {
 public:
  ClientIdentificationEvent();
  virtual ~ClientIdentificationEvent();

  ClientIdentificationEvent(const ClientIdentificationEvent& from);

  inline ClientIdentificationEvent& operator=(const ClientIdentificationEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientIdentificationEvent& default_instance();

  void Swap(ClientIdentificationEvent* other);

  // implements Message ----------------------------------------------

  inline ClientIdentificationEvent* New() const { return New(NULL); }

  ClientIdentificationEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientIdentificationEvent& from);
  void MergeFrom(const ClientIdentificationEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientIdentificationEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 dll_major = 1;
  void clear_dll_major();
  static const int kDllMajorFieldNumber = 1;
  ::google::protobuf::int32 dll_major() const;
  void set_dll_major(::google::protobuf::int32 value);

  // optional int32 dll_minor = 2;
  void clear_dll_minor();
  static const int kDllMinorFieldNumber = 2;
  ::google::protobuf::int32 dll_minor() const;
  void set_dll_minor(::google::protobuf::int32 value);

  // optional int32 dll_patch = 3;
  void clear_dll_patch();
  static const int kDllPatchFieldNumber = 3;
  ::google::protobuf::int32 dll_patch() const;
  void set_dll_patch(::google::protobuf::int32 value);

  // optional string app_name = 4;
  void clear_app_name();
  static const int kAppNameFieldNumber = 4;
  const ::std::string& app_name() const;
  void set_app_name(const ::std::string& value);
  void set_app_name(const char* value);
  void set_app_name(const char* value, size_t size);
  ::std::string* mutable_app_name();
  ::std::string* release_app_name();
  void set_allocated_app_name(::std::string* app_name);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.ClientIdentificationEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 dll_major_;
  ::google::protobuf::int32 dll_minor_;
  ::google::protobuf::internal::ArenaStringPtr app_name_;
  ::google::protobuf::int32 dll_patch_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static ClientIdentificationEvent* default_instance_;
};
// -------------------------------------------------------------------

class RegionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.RegionList) */ {
 public:
  RegionList();
  virtual ~RegionList();

  RegionList(const RegionList& from);

  inline RegionList& operator=(const RegionList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionList& default_instance();

  void Swap(RegionList* other);

  // implements Message ----------------------------------------------

  inline RegionList* New() const { return New(NULL); }

  RegionList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionList& from);
  void MergeFrom(const RegionList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 regions = 1;
  int regions_size() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 1;
  ::google::protobuf::uint32 regions(int index) const;
  void set_regions(int index, ::google::protobuf::uint32 value);
  void add_regions(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      regions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_regions();

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.RegionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > regions_;
  mutable int _regions_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static RegionList* default_instance_;
};
// -------------------------------------------------------------------

class NodeList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.NodeList) */ {
 public:
  NodeList();
  virtual ~NodeList();

  NodeList(const NodeList& from);

  inline NodeList& operator=(const NodeList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeList& default_instance();

  void Swap(NodeList* other);

  // implements Message ----------------------------------------------

  inline NodeList* New() const { return New(NULL); }

  NodeList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeList& from);
  void MergeFrom(const NodeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::google::protobuf::uint32 nodes(int index) const;
  void set_nodes(int index, ::google::protobuf::uint32 value);
  void add_nodes(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      nodes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.NodeList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > nodes_;
  mutable int _nodes_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static NodeList* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  enum WhereCase {
    kRegions = 1,
    kNodes = 2,
    WHERE_NOT_SET = 0,
  };

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  inline Location* New() const { return New(NULL); }

  Location* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .NullSpaceIPC.RegionList regions = 1;
  bool has_regions() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 1;
  const ::NullSpaceIPC::RegionList& regions() const;
  ::NullSpaceIPC::RegionList* mutable_regions();
  ::NullSpaceIPC::RegionList* release_regions();
  void set_allocated_regions(::NullSpaceIPC::RegionList* regions);

  // optional .NullSpaceIPC.NodeList nodes = 2;
  bool has_nodes() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 2;
  const ::NullSpaceIPC::NodeList& nodes() const;
  ::NullSpaceIPC::NodeList* mutable_nodes();
  ::NullSpaceIPC::NodeList* release_nodes();
  void set_allocated_nodes(::NullSpaceIPC::NodeList* nodes);

  WhereCase where_case() const;
  // @@protoc_insertion_point(class_scope:NullSpaceIPC.Location)
 private:
  inline void set_has_regions();
  inline void set_has_nodes();

  inline bool has_where() const;
  void clear_where();
  inline void clear_has_where();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union WhereUnion {
    WhereUnion() {}
    ::NullSpaceIPC::RegionList* regions_;
    ::NullSpaceIPC::NodeList* nodes_;
  } where_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class SimpleHaptic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.SimpleHaptic) */ {
 public:
  SimpleHaptic();
  virtual ~SimpleHaptic();

  SimpleHaptic(const SimpleHaptic& from);

  inline SimpleHaptic& operator=(const SimpleHaptic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleHaptic& default_instance();

  void Swap(SimpleHaptic* other);

  // implements Message ----------------------------------------------

  inline SimpleHaptic* New() const { return New(NULL); }

  SimpleHaptic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleHaptic& from);
  void MergeFrom(const SimpleHaptic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleHaptic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 effect = 1;
  void clear_effect();
  static const int kEffectFieldNumber = 1;
  ::google::protobuf::uint32 effect() const;
  void set_effect(::google::protobuf::uint32 value);

  // optional uint32 repetitions = 2;
  void clear_repetitions();
  static const int kRepetitionsFieldNumber = 2;
  ::google::protobuf::uint32 repetitions() const;
  void set_repetitions(::google::protobuf::uint32 value);

  // optional float strength = 3;
  void clear_strength();
  static const int kStrengthFieldNumber = 3;
  float strength() const;
  void set_strength(float value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.SimpleHaptic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 effect_;
  ::google::protobuf::uint32 repetitions_;
  float strength_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static SimpleHaptic* default_instance_;
};
// -------------------------------------------------------------------

class ContinuousHaptic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.ContinuousHaptic) */ {
 public:
  ContinuousHaptic();
  virtual ~ContinuousHaptic();

  ContinuousHaptic(const ContinuousHaptic& from);

  inline ContinuousHaptic& operator=(const ContinuousHaptic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContinuousHaptic& default_instance();

  void Swap(ContinuousHaptic* other);

  // implements Message ----------------------------------------------

  inline ContinuousHaptic* New() const { return New(NULL); }

  ContinuousHaptic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContinuousHaptic& from);
  void MergeFrom(const ContinuousHaptic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContinuousHaptic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float strength = 1;
  void clear_strength();
  static const int kStrengthFieldNumber = 1;
  float strength() const;
  void set_strength(float value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.ContinuousHaptic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float strength_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static ContinuousHaptic* default_instance_;
};
// -------------------------------------------------------------------

class BufferedHaptic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.BufferedHaptic) */ {
 public:
  BufferedHaptic();
  virtual ~BufferedHaptic();

  BufferedHaptic(const BufferedHaptic& from);

  inline BufferedHaptic& operator=(const BufferedHaptic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferedHaptic& default_instance();

  void Swap(BufferedHaptic* other);

  // implements Message ----------------------------------------------

  inline BufferedHaptic* New() const { return New(NULL); }

  BufferedHaptic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BufferedHaptic& from);
  void MergeFrom(const BufferedHaptic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BufferedHaptic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float samples = 1;
  int samples_size() const;
  void clear_samples();
  static const int kSamplesFieldNumber = 1;
  float samples(int index) const;
  void set_samples(int index, float value);
  void add_samples(float value);
  const ::google::protobuf::RepeatedField< float >&
      samples() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_samples();

  // optional float frequency = 2;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 2;
  float frequency() const;
  void set_frequency(float value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.BufferedHaptic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< float > samples_;
  mutable int _samples_cached_byte_size_;
  float frequency_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static BufferedHaptic* default_instance_;
};
// -------------------------------------------------------------------

class BeginAnalogAudio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.BeginAnalogAudio) */ {
 public:
  BeginAnalogAudio();
  virtual ~BeginAnalogAudio();

  BeginAnalogAudio(const BeginAnalogAudio& from);

  inline BeginAnalogAudio& operator=(const BeginAnalogAudio& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BeginAnalogAudio& default_instance();

  void Swap(BeginAnalogAudio* other);

  // implements Message ----------------------------------------------

  inline BeginAnalogAudio* New() const { return New(NULL); }

  BeginAnalogAudio* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BeginAnalogAudio& from);
  void MergeFrom(const BeginAnalogAudio& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BeginAnalogAudio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.BeginAnalogAudio)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static BeginAnalogAudio* default_instance_;
};
// -------------------------------------------------------------------

class EndAnalogAudio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.EndAnalogAudio) */ {
 public:
  EndAnalogAudio();
  virtual ~EndAnalogAudio();

  EndAnalogAudio(const EndAnalogAudio& from);

  inline EndAnalogAudio& operator=(const EndAnalogAudio& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndAnalogAudio& default_instance();

  void Swap(EndAnalogAudio* other);

  // implements Message ----------------------------------------------

  inline EndAnalogAudio* New() const { return New(NULL); }

  EndAnalogAudio* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndAnalogAudio& from);
  void MergeFrom(const EndAnalogAudio& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndAnalogAudio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.EndAnalogAudio)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static EndAnalogAudio* default_instance_;
};
// -------------------------------------------------------------------

class PlaybackEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.PlaybackEvent) */ {
 public:
  PlaybackEvent();
  virtual ~PlaybackEvent();

  PlaybackEvent(const PlaybackEvent& from);

  inline PlaybackEvent& operator=(const PlaybackEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaybackEvent& default_instance();

  void Swap(PlaybackEvent* other);

  // implements Message ----------------------------------------------

  inline PlaybackEvent* New() const { return New(NULL); }

  PlaybackEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaybackEvent& from);
  void MergeFrom(const PlaybackEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlaybackEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlaybackEvent_Command Command;
  static const Command UNKNOWN =
    PlaybackEvent_Command_UNKNOWN;
  static const Command PAUSE =
    PlaybackEvent_Command_PAUSE;
  static const Command UNPAUSE =
    PlaybackEvent_Command_UNPAUSE;
  static const Command CANCEL =
    PlaybackEvent_Command_CANCEL;
  static inline bool Command_IsValid(int value) {
    return PlaybackEvent_Command_IsValid(value);
  }
  static const Command Command_MIN =
    PlaybackEvent_Command_Command_MIN;
  static const Command Command_MAX =
    PlaybackEvent_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    PlaybackEvent_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return PlaybackEvent_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return PlaybackEvent_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return PlaybackEvent_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .NullSpaceIPC.PlaybackEvent.Command command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::NullSpaceIPC::PlaybackEvent_Command command() const;
  void set_command(::NullSpaceIPC::PlaybackEvent_Command value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.PlaybackEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int command_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static PlaybackEvent* default_instance_;
};
// -------------------------------------------------------------------

class LocationalEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.LocationalEvent) */ {
 public:
  LocationalEvent();
  virtual ~LocationalEvent();

  LocationalEvent(const LocationalEvent& from);

  inline LocationalEvent& operator=(const LocationalEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationalEvent& default_instance();

  enum EventsCase {
    kSimpleHaptic = 2,
    kContinuousHaptic = 3,
    kBufferedHaptic = 4,
    kBeginAnalogAudio = 16,
    kEndAnalogAudio = 17,
    EVENTS_NOT_SET = 0,
  };

  void Swap(LocationalEvent* other);

  // implements Message ----------------------------------------------

  inline LocationalEvent* New() const { return New(NULL); }

  LocationalEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocationalEvent& from);
  void MergeFrom(const LocationalEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocationalEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .NullSpaceIPC.Location location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::NullSpaceIPC::Location& location() const;
  ::NullSpaceIPC::Location* mutable_location();
  ::NullSpaceIPC::Location* release_location();
  void set_allocated_location(::NullSpaceIPC::Location* location);

  // optional .NullSpaceIPC.SimpleHaptic simple_haptic = 2;
  bool has_simple_haptic() const;
  void clear_simple_haptic();
  static const int kSimpleHapticFieldNumber = 2;
  const ::NullSpaceIPC::SimpleHaptic& simple_haptic() const;
  ::NullSpaceIPC::SimpleHaptic* mutable_simple_haptic();
  ::NullSpaceIPC::SimpleHaptic* release_simple_haptic();
  void set_allocated_simple_haptic(::NullSpaceIPC::SimpleHaptic* simple_haptic);

  // optional .NullSpaceIPC.ContinuousHaptic continuous_haptic = 3;
  bool has_continuous_haptic() const;
  void clear_continuous_haptic();
  static const int kContinuousHapticFieldNumber = 3;
  const ::NullSpaceIPC::ContinuousHaptic& continuous_haptic() const;
  ::NullSpaceIPC::ContinuousHaptic* mutable_continuous_haptic();
  ::NullSpaceIPC::ContinuousHaptic* release_continuous_haptic();
  void set_allocated_continuous_haptic(::NullSpaceIPC::ContinuousHaptic* continuous_haptic);

  // optional .NullSpaceIPC.BufferedHaptic buffered_haptic = 4;
  bool has_buffered_haptic() const;
  void clear_buffered_haptic();
  static const int kBufferedHapticFieldNumber = 4;
  const ::NullSpaceIPC::BufferedHaptic& buffered_haptic() const;
  ::NullSpaceIPC::BufferedHaptic* mutable_buffered_haptic();
  ::NullSpaceIPC::BufferedHaptic* release_buffered_haptic();
  void set_allocated_buffered_haptic(::NullSpaceIPC::BufferedHaptic* buffered_haptic);

  // optional .NullSpaceIPC.BeginAnalogAudio begin_analog_audio = 16;
  bool has_begin_analog_audio() const;
  void clear_begin_analog_audio();
  static const int kBeginAnalogAudioFieldNumber = 16;
  const ::NullSpaceIPC::BeginAnalogAudio& begin_analog_audio() const;
  ::NullSpaceIPC::BeginAnalogAudio* mutable_begin_analog_audio();
  ::NullSpaceIPC::BeginAnalogAudio* release_begin_analog_audio();
  void set_allocated_begin_analog_audio(::NullSpaceIPC::BeginAnalogAudio* begin_analog_audio);

  // optional .NullSpaceIPC.EndAnalogAudio end_analog_audio = 17;
  bool has_end_analog_audio() const;
  void clear_end_analog_audio();
  static const int kEndAnalogAudioFieldNumber = 17;
  const ::NullSpaceIPC::EndAnalogAudio& end_analog_audio() const;
  ::NullSpaceIPC::EndAnalogAudio* mutable_end_analog_audio();
  ::NullSpaceIPC::EndAnalogAudio* release_end_analog_audio();
  void set_allocated_end_analog_audio(::NullSpaceIPC::EndAnalogAudio* end_analog_audio);

  EventsCase events_case() const;
  // @@protoc_insertion_point(class_scope:NullSpaceIPC.LocationalEvent)
 private:
  inline void set_has_simple_haptic();
  inline void set_has_continuous_haptic();
  inline void set_has_buffered_haptic();
  inline void set_has_begin_analog_audio();
  inline void set_has_end_analog_audio();

  inline bool has_events() const;
  void clear_events();
  inline void clear_has_events();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::NullSpaceIPC::Location* location_;
  union EventsUnion {
    EventsUnion() {}
    ::NullSpaceIPC::SimpleHaptic* simple_haptic_;
    ::NullSpaceIPC::ContinuousHaptic* continuous_haptic_;
    ::NullSpaceIPC::BufferedHaptic* buffered_haptic_;
    ::NullSpaceIPC::BeginAnalogAudio* begin_analog_audio_;
    ::NullSpaceIPC::EndAnalogAudio* end_analog_audio_;
  } events_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static LocationalEvent* default_instance_;
};
// -------------------------------------------------------------------

class EnableTracking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.EnableTracking) */ {
 public:
  EnableTracking();
  virtual ~EnableTracking();

  EnableTracking(const EnableTracking& from);

  inline EnableTracking& operator=(const EnableTracking& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableTracking& default_instance();

  void Swap(EnableTracking* other);

  // implements Message ----------------------------------------------

  inline EnableTracking* New() const { return New(NULL); }

  EnableTracking* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnableTracking& from);
  void MergeFrom(const EnableTracking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnableTracking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.EnableTracking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static EnableTracking* default_instance_;
};
// -------------------------------------------------------------------

class DisableTracking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.DisableTracking) */ {
 public:
  DisableTracking();
  virtual ~DisableTracking();

  DisableTracking(const DisableTracking& from);

  inline DisableTracking& operator=(const DisableTracking& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisableTracking& default_instance();

  void Swap(DisableTracking* other);

  // implements Message ----------------------------------------------

  inline DisableTracking* New() const { return New(NULL); }

  DisableTracking* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisableTracking& from);
  void MergeFrom(const DisableTracking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisableTracking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.DisableTracking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static DisableTracking* default_instance_;
};
// -------------------------------------------------------------------

class DeviceEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.DeviceEvent) */ {
 public:
  DeviceEvent();
  virtual ~DeviceEvent();

  DeviceEvent(const DeviceEvent& from);

  inline DeviceEvent& operator=(const DeviceEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceEvent& default_instance();

  enum EventsCase {
    kEnableTracking = 16,
    kDisableTracking = 17,
    EVENTS_NOT_SET = 0,
  };

  void Swap(DeviceEvent* other);

  // implements Message ----------------------------------------------

  inline DeviceEvent* New() const { return New(NULL); }

  DeviceEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceEvent& from);
  void MergeFrom(const DeviceEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  ::google::protobuf::uint32 device() const;
  void set_device(::google::protobuf::uint32 value);

  // optional .NullSpaceIPC.EnableTracking enable_tracking = 16;
  bool has_enable_tracking() const;
  void clear_enable_tracking();
  static const int kEnableTrackingFieldNumber = 16;
  const ::NullSpaceIPC::EnableTracking& enable_tracking() const;
  ::NullSpaceIPC::EnableTracking* mutable_enable_tracking();
  ::NullSpaceIPC::EnableTracking* release_enable_tracking();
  void set_allocated_enable_tracking(::NullSpaceIPC::EnableTracking* enable_tracking);

  // optional .NullSpaceIPC.DisableTracking disable_tracking = 17;
  bool has_disable_tracking() const;
  void clear_disable_tracking();
  static const int kDisableTrackingFieldNumber = 17;
  const ::NullSpaceIPC::DisableTracking& disable_tracking() const;
  ::NullSpaceIPC::DisableTracking* mutable_disable_tracking();
  ::NullSpaceIPC::DisableTracking* release_disable_tracking();
  void set_allocated_disable_tracking(::NullSpaceIPC::DisableTracking* disable_tracking);

  EventsCase events_case() const;
  // @@protoc_insertion_point(class_scope:NullSpaceIPC.DeviceEvent)
 private:
  inline void set_has_enable_tracking();
  inline void set_has_disable_tracking();

  inline bool has_events() const;
  void clear_events();
  inline void clear_has_events();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 device_;
  union EventsUnion {
    EventsUnion() {}
    ::NullSpaceIPC::EnableTracking* enable_tracking_;
    ::NullSpaceIPC::DisableTracking* disable_tracking_;
  } events_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static DeviceEvent* default_instance_;
};
// -------------------------------------------------------------------

class HighLevelEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.HighLevelEvent) */ {
 public:
  HighLevelEvent();
  virtual ~HighLevelEvent();

  HighLevelEvent(const HighLevelEvent& from);

  inline HighLevelEvent& operator=(const HighLevelEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HighLevelEvent& default_instance();

  enum EventsCase {
    kPlaybackEvent = 2,
    kLocationalEvent = 3,
    kDeviceEvent = 4,
    kClientIdEvent = 16,
    EVENTS_NOT_SET = 0,
  };

  void Swap(HighLevelEvent* other);

  // implements Message ----------------------------------------------

  inline HighLevelEvent* New() const { return New(NULL); }

  HighLevelEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HighLevelEvent& from);
  void MergeFrom(const HighLevelEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HighLevelEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 parent_id = 1;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 1;
  ::google::protobuf::uint64 parent_id() const;
  void set_parent_id(::google::protobuf::uint64 value);

  // optional .NullSpaceIPC.PlaybackEvent playback_event = 2;
  bool has_playback_event() const;
  void clear_playback_event();
  static const int kPlaybackEventFieldNumber = 2;
  const ::NullSpaceIPC::PlaybackEvent& playback_event() const;
  ::NullSpaceIPC::PlaybackEvent* mutable_playback_event();
  ::NullSpaceIPC::PlaybackEvent* release_playback_event();
  void set_allocated_playback_event(::NullSpaceIPC::PlaybackEvent* playback_event);

  // optional .NullSpaceIPC.LocationalEvent locational_event = 3;
  bool has_locational_event() const;
  void clear_locational_event();
  static const int kLocationalEventFieldNumber = 3;
  const ::NullSpaceIPC::LocationalEvent& locational_event() const;
  ::NullSpaceIPC::LocationalEvent* mutable_locational_event();
  ::NullSpaceIPC::LocationalEvent* release_locational_event();
  void set_allocated_locational_event(::NullSpaceIPC::LocationalEvent* locational_event);

  // optional .NullSpaceIPC.DeviceEvent device_event = 4;
  bool has_device_event() const;
  void clear_device_event();
  static const int kDeviceEventFieldNumber = 4;
  const ::NullSpaceIPC::DeviceEvent& device_event() const;
  ::NullSpaceIPC::DeviceEvent* mutable_device_event();
  ::NullSpaceIPC::DeviceEvent* release_device_event();
  void set_allocated_device_event(::NullSpaceIPC::DeviceEvent* device_event);

  // optional .NullSpaceIPC.ClientIdentificationEvent client_id_event = 16;
  bool has_client_id_event() const;
  void clear_client_id_event();
  static const int kClientIdEventFieldNumber = 16;
  const ::NullSpaceIPC::ClientIdentificationEvent& client_id_event() const;
  ::NullSpaceIPC::ClientIdentificationEvent* mutable_client_id_event();
  ::NullSpaceIPC::ClientIdentificationEvent* release_client_id_event();
  void set_allocated_client_id_event(::NullSpaceIPC::ClientIdentificationEvent* client_id_event);

  EventsCase events_case() const;
  // @@protoc_insertion_point(class_scope:NullSpaceIPC.HighLevelEvent)
 private:
  inline void set_has_playback_event();
  inline void set_has_locational_event();
  inline void set_has_device_event();
  inline void set_has_client_id_event();

  inline bool has_events() const;
  void clear_events();
  inline void clear_has_events();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 parent_id_;
  union EventsUnion {
    EventsUnion() {}
    ::NullSpaceIPC::PlaybackEvent* playback_event_;
    ::NullSpaceIPC::LocationalEvent* locational_event_;
    ::NullSpaceIPC::DeviceEvent* device_event_;
    ::NullSpaceIPC::ClientIdentificationEvent* client_id_event_;
  } events_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static HighLevelEvent* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientIdentificationEvent

// optional int32 dll_major = 1;
inline void ClientIdentificationEvent::clear_dll_major() {
  dll_major_ = 0;
}
inline ::google::protobuf::int32 ClientIdentificationEvent::dll_major() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.ClientIdentificationEvent.dll_major)
  return dll_major_;
}
inline void ClientIdentificationEvent::set_dll_major(::google::protobuf::int32 value) {
  
  dll_major_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.ClientIdentificationEvent.dll_major)
}

// optional int32 dll_minor = 2;
inline void ClientIdentificationEvent::clear_dll_minor() {
  dll_minor_ = 0;
}
inline ::google::protobuf::int32 ClientIdentificationEvent::dll_minor() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.ClientIdentificationEvent.dll_minor)
  return dll_minor_;
}
inline void ClientIdentificationEvent::set_dll_minor(::google::protobuf::int32 value) {
  
  dll_minor_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.ClientIdentificationEvent.dll_minor)
}

// optional int32 dll_patch = 3;
inline void ClientIdentificationEvent::clear_dll_patch() {
  dll_patch_ = 0;
}
inline ::google::protobuf::int32 ClientIdentificationEvent::dll_patch() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.ClientIdentificationEvent.dll_patch)
  return dll_patch_;
}
inline void ClientIdentificationEvent::set_dll_patch(::google::protobuf::int32 value) {
  
  dll_patch_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.ClientIdentificationEvent.dll_patch)
}

// optional string app_name = 4;
inline void ClientIdentificationEvent::clear_app_name() {
  app_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientIdentificationEvent::app_name() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.ClientIdentificationEvent.app_name)
  return app_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientIdentificationEvent::set_app_name(const ::std::string& value) {
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NullSpaceIPC.ClientIdentificationEvent.app_name)
}
inline void ClientIdentificationEvent::set_app_name(const char* value) {
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NullSpaceIPC.ClientIdentificationEvent.app_name)
}
inline void ClientIdentificationEvent::set_app_name(const char* value, size_t size) {
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NullSpaceIPC.ClientIdentificationEvent.app_name)
}
inline ::std::string* ClientIdentificationEvent::mutable_app_name() {
  
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.ClientIdentificationEvent.app_name)
  return app_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientIdentificationEvent::release_app_name() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.ClientIdentificationEvent.app_name)
  
  return app_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientIdentificationEvent::set_allocated_app_name(::std::string* app_name) {
  if (app_name != NULL) {
    
  } else {
    
  }
  app_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_name);
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.ClientIdentificationEvent.app_name)
}

// -------------------------------------------------------------------

// RegionList

// repeated uint32 regions = 1;
inline int RegionList::regions_size() const {
  return regions_.size();
}
inline void RegionList::clear_regions() {
  regions_.Clear();
}
inline ::google::protobuf::uint32 RegionList::regions(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.RegionList.regions)
  return regions_.Get(index);
}
inline void RegionList::set_regions(int index, ::google::protobuf::uint32 value) {
  regions_.Set(index, value);
  // @@protoc_insertion_point(field_set:NullSpaceIPC.RegionList.regions)
}
inline void RegionList::add_regions(::google::protobuf::uint32 value) {
  regions_.Add(value);
  // @@protoc_insertion_point(field_add:NullSpaceIPC.RegionList.regions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RegionList::regions() const {
  // @@protoc_insertion_point(field_list:NullSpaceIPC.RegionList.regions)
  return regions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RegionList::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceIPC.RegionList.regions)
  return &regions_;
}

// -------------------------------------------------------------------

// NodeList

// repeated uint32 nodes = 1;
inline int NodeList::nodes_size() const {
  return nodes_.size();
}
inline void NodeList::clear_nodes() {
  nodes_.Clear();
}
inline ::google::protobuf::uint32 NodeList::nodes(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.NodeList.nodes)
  return nodes_.Get(index);
}
inline void NodeList::set_nodes(int index, ::google::protobuf::uint32 value) {
  nodes_.Set(index, value);
  // @@protoc_insertion_point(field_set:NullSpaceIPC.NodeList.nodes)
}
inline void NodeList::add_nodes(::google::protobuf::uint32 value) {
  nodes_.Add(value);
  // @@protoc_insertion_point(field_add:NullSpaceIPC.NodeList.nodes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NodeList::nodes() const {
  // @@protoc_insertion_point(field_list:NullSpaceIPC.NodeList.nodes)
  return nodes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NodeList::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceIPC.NodeList.nodes)
  return &nodes_;
}

// -------------------------------------------------------------------

// Location

// optional .NullSpaceIPC.RegionList regions = 1;
inline bool Location::has_regions() const {
  return where_case() == kRegions;
}
inline void Location::set_has_regions() {
  _oneof_case_[0] = kRegions;
}
inline void Location::clear_regions() {
  if (has_regions()) {
    delete where_.regions_;
    clear_has_where();
  }
}
inline  const ::NullSpaceIPC::RegionList& Location::regions() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.Location.regions)
  return has_regions()
      ? *where_.regions_
      : ::NullSpaceIPC::RegionList::default_instance();
}
inline ::NullSpaceIPC::RegionList* Location::mutable_regions() {
  if (!has_regions()) {
    clear_where();
    set_has_regions();
    where_.regions_ = new ::NullSpaceIPC::RegionList;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.Location.regions)
  return where_.regions_;
}
inline ::NullSpaceIPC::RegionList* Location::release_regions() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.Location.regions)
  if (has_regions()) {
    clear_has_where();
    ::NullSpaceIPC::RegionList* temp = where_.regions_;
    where_.regions_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Location::set_allocated_regions(::NullSpaceIPC::RegionList* regions) {
  clear_where();
  if (regions) {
    set_has_regions();
    where_.regions_ = regions;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.Location.regions)
}

// optional .NullSpaceIPC.NodeList nodes = 2;
inline bool Location::has_nodes() const {
  return where_case() == kNodes;
}
inline void Location::set_has_nodes() {
  _oneof_case_[0] = kNodes;
}
inline void Location::clear_nodes() {
  if (has_nodes()) {
    delete where_.nodes_;
    clear_has_where();
  }
}
inline  const ::NullSpaceIPC::NodeList& Location::nodes() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.Location.nodes)
  return has_nodes()
      ? *where_.nodes_
      : ::NullSpaceIPC::NodeList::default_instance();
}
inline ::NullSpaceIPC::NodeList* Location::mutable_nodes() {
  if (!has_nodes()) {
    clear_where();
    set_has_nodes();
    where_.nodes_ = new ::NullSpaceIPC::NodeList;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.Location.nodes)
  return where_.nodes_;
}
inline ::NullSpaceIPC::NodeList* Location::release_nodes() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.Location.nodes)
  if (has_nodes()) {
    clear_has_where();
    ::NullSpaceIPC::NodeList* temp = where_.nodes_;
    where_.nodes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Location::set_allocated_nodes(::NullSpaceIPC::NodeList* nodes) {
  clear_where();
  if (nodes) {
    set_has_nodes();
    where_.nodes_ = nodes;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.Location.nodes)
}

inline bool Location::has_where() const {
  return where_case() != WHERE_NOT_SET;
}
inline void Location::clear_has_where() {
  _oneof_case_[0] = WHERE_NOT_SET;
}
inline Location::WhereCase Location::where_case() const {
  return Location::WhereCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SimpleHaptic

// optional uint32 effect = 1;
inline void SimpleHaptic::clear_effect() {
  effect_ = 0u;
}
inline ::google::protobuf::uint32 SimpleHaptic::effect() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.SimpleHaptic.effect)
  return effect_;
}
inline void SimpleHaptic::set_effect(::google::protobuf::uint32 value) {
  
  effect_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.SimpleHaptic.effect)
}

// optional uint32 repetitions = 2;
inline void SimpleHaptic::clear_repetitions() {
  repetitions_ = 0u;
}
inline ::google::protobuf::uint32 SimpleHaptic::repetitions() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.SimpleHaptic.repetitions)
  return repetitions_;
}
inline void SimpleHaptic::set_repetitions(::google::protobuf::uint32 value) {
  
  repetitions_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.SimpleHaptic.repetitions)
}

// optional float strength = 3;
inline void SimpleHaptic::clear_strength() {
  strength_ = 0;
}
inline float SimpleHaptic::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.SimpleHaptic.strength)
  return strength_;
}
inline void SimpleHaptic::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.SimpleHaptic.strength)
}

// -------------------------------------------------------------------

// ContinuousHaptic

// optional float strength = 1;
inline void ContinuousHaptic::clear_strength() {
  strength_ = 0;
}
inline float ContinuousHaptic::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.ContinuousHaptic.strength)
  return strength_;
}
inline void ContinuousHaptic::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.ContinuousHaptic.strength)
}

// -------------------------------------------------------------------

// BufferedHaptic

// repeated float samples = 1;
inline int BufferedHaptic::samples_size() const {
  return samples_.size();
}
inline void BufferedHaptic::clear_samples() {
  samples_.Clear();
}
inline float BufferedHaptic::samples(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.BufferedHaptic.samples)
  return samples_.Get(index);
}
inline void BufferedHaptic::set_samples(int index, float value) {
  samples_.Set(index, value);
  // @@protoc_insertion_point(field_set:NullSpaceIPC.BufferedHaptic.samples)
}
inline void BufferedHaptic::add_samples(float value) {
  samples_.Add(value);
  // @@protoc_insertion_point(field_add:NullSpaceIPC.BufferedHaptic.samples)
}
inline const ::google::protobuf::RepeatedField< float >&
BufferedHaptic::samples() const {
  // @@protoc_insertion_point(field_list:NullSpaceIPC.BufferedHaptic.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedField< float >*
BufferedHaptic::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceIPC.BufferedHaptic.samples)
  return &samples_;
}

// optional float frequency = 2;
inline void BufferedHaptic::clear_frequency() {
  frequency_ = 0;
}
inline float BufferedHaptic::frequency() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.BufferedHaptic.frequency)
  return frequency_;
}
inline void BufferedHaptic::set_frequency(float value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.BufferedHaptic.frequency)
}

// -------------------------------------------------------------------

// BeginAnalogAudio

// -------------------------------------------------------------------

// EndAnalogAudio

// -------------------------------------------------------------------

// PlaybackEvent

// optional .NullSpaceIPC.PlaybackEvent.Command command = 1;
inline void PlaybackEvent::clear_command() {
  command_ = 0;
}
inline ::NullSpaceIPC::PlaybackEvent_Command PlaybackEvent::command() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.PlaybackEvent.command)
  return static_cast< ::NullSpaceIPC::PlaybackEvent_Command >(command_);
}
inline void PlaybackEvent::set_command(::NullSpaceIPC::PlaybackEvent_Command value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.PlaybackEvent.command)
}

// -------------------------------------------------------------------

// LocationalEvent

// optional .NullSpaceIPC.Location location = 1;
inline bool LocationalEvent::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void LocationalEvent::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::NullSpaceIPC::Location& LocationalEvent::location() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.LocationalEvent.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::NullSpaceIPC::Location* LocationalEvent::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::NullSpaceIPC::Location;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.LocationalEvent.location)
  return location_;
}
inline ::NullSpaceIPC::Location* LocationalEvent::release_location() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.LocationalEvent.location)
  
  ::NullSpaceIPC::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void LocationalEvent::set_allocated_location(::NullSpaceIPC::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.LocationalEvent.location)
}

// optional .NullSpaceIPC.SimpleHaptic simple_haptic = 2;
inline bool LocationalEvent::has_simple_haptic() const {
  return events_case() == kSimpleHaptic;
}
inline void LocationalEvent::set_has_simple_haptic() {
  _oneof_case_[0] = kSimpleHaptic;
}
inline void LocationalEvent::clear_simple_haptic() {
  if (has_simple_haptic()) {
    delete events_.simple_haptic_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::SimpleHaptic& LocationalEvent::simple_haptic() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.LocationalEvent.simple_haptic)
  return has_simple_haptic()
      ? *events_.simple_haptic_
      : ::NullSpaceIPC::SimpleHaptic::default_instance();
}
inline ::NullSpaceIPC::SimpleHaptic* LocationalEvent::mutable_simple_haptic() {
  if (!has_simple_haptic()) {
    clear_events();
    set_has_simple_haptic();
    events_.simple_haptic_ = new ::NullSpaceIPC::SimpleHaptic;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.LocationalEvent.simple_haptic)
  return events_.simple_haptic_;
}
inline ::NullSpaceIPC::SimpleHaptic* LocationalEvent::release_simple_haptic() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.LocationalEvent.simple_haptic)
  if (has_simple_haptic()) {
    clear_has_events();
    ::NullSpaceIPC::SimpleHaptic* temp = events_.simple_haptic_;
    events_.simple_haptic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocationalEvent::set_allocated_simple_haptic(::NullSpaceIPC::SimpleHaptic* simple_haptic) {
  clear_events();
  if (simple_haptic) {
    set_has_simple_haptic();
    events_.simple_haptic_ = simple_haptic;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.LocationalEvent.simple_haptic)
}

// optional .NullSpaceIPC.ContinuousHaptic continuous_haptic = 3;
inline bool LocationalEvent::has_continuous_haptic() const {
  return events_case() == kContinuousHaptic;
}
inline void LocationalEvent::set_has_continuous_haptic() {
  _oneof_case_[0] = kContinuousHaptic;
}
inline void LocationalEvent::clear_continuous_haptic() {
  if (has_continuous_haptic()) {
    delete events_.continuous_haptic_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::ContinuousHaptic& LocationalEvent::continuous_haptic() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.LocationalEvent.continuous_haptic)
  return has_continuous_haptic()
      ? *events_.continuous_haptic_
      : ::NullSpaceIPC::ContinuousHaptic::default_instance();
}
inline ::NullSpaceIPC::ContinuousHaptic* LocationalEvent::mutable_continuous_haptic() {
  if (!has_continuous_haptic()) {
    clear_events();
    set_has_continuous_haptic();
    events_.continuous_haptic_ = new ::NullSpaceIPC::ContinuousHaptic;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.LocationalEvent.continuous_haptic)
  return events_.continuous_haptic_;
}
inline ::NullSpaceIPC::ContinuousHaptic* LocationalEvent::release_continuous_haptic() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.LocationalEvent.continuous_haptic)
  if (has_continuous_haptic()) {
    clear_has_events();
    ::NullSpaceIPC::ContinuousHaptic* temp = events_.continuous_haptic_;
    events_.continuous_haptic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocationalEvent::set_allocated_continuous_haptic(::NullSpaceIPC::ContinuousHaptic* continuous_haptic) {
  clear_events();
  if (continuous_haptic) {
    set_has_continuous_haptic();
    events_.continuous_haptic_ = continuous_haptic;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.LocationalEvent.continuous_haptic)
}

// optional .NullSpaceIPC.BufferedHaptic buffered_haptic = 4;
inline bool LocationalEvent::has_buffered_haptic() const {
  return events_case() == kBufferedHaptic;
}
inline void LocationalEvent::set_has_buffered_haptic() {
  _oneof_case_[0] = kBufferedHaptic;
}
inline void LocationalEvent::clear_buffered_haptic() {
  if (has_buffered_haptic()) {
    delete events_.buffered_haptic_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::BufferedHaptic& LocationalEvent::buffered_haptic() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.LocationalEvent.buffered_haptic)
  return has_buffered_haptic()
      ? *events_.buffered_haptic_
      : ::NullSpaceIPC::BufferedHaptic::default_instance();
}
inline ::NullSpaceIPC::BufferedHaptic* LocationalEvent::mutable_buffered_haptic() {
  if (!has_buffered_haptic()) {
    clear_events();
    set_has_buffered_haptic();
    events_.buffered_haptic_ = new ::NullSpaceIPC::BufferedHaptic;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.LocationalEvent.buffered_haptic)
  return events_.buffered_haptic_;
}
inline ::NullSpaceIPC::BufferedHaptic* LocationalEvent::release_buffered_haptic() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.LocationalEvent.buffered_haptic)
  if (has_buffered_haptic()) {
    clear_has_events();
    ::NullSpaceIPC::BufferedHaptic* temp = events_.buffered_haptic_;
    events_.buffered_haptic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocationalEvent::set_allocated_buffered_haptic(::NullSpaceIPC::BufferedHaptic* buffered_haptic) {
  clear_events();
  if (buffered_haptic) {
    set_has_buffered_haptic();
    events_.buffered_haptic_ = buffered_haptic;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.LocationalEvent.buffered_haptic)
}

// optional .NullSpaceIPC.BeginAnalogAudio begin_analog_audio = 16;
inline bool LocationalEvent::has_begin_analog_audio() const {
  return events_case() == kBeginAnalogAudio;
}
inline void LocationalEvent::set_has_begin_analog_audio() {
  _oneof_case_[0] = kBeginAnalogAudio;
}
inline void LocationalEvent::clear_begin_analog_audio() {
  if (has_begin_analog_audio()) {
    delete events_.begin_analog_audio_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::BeginAnalogAudio& LocationalEvent::begin_analog_audio() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.LocationalEvent.begin_analog_audio)
  return has_begin_analog_audio()
      ? *events_.begin_analog_audio_
      : ::NullSpaceIPC::BeginAnalogAudio::default_instance();
}
inline ::NullSpaceIPC::BeginAnalogAudio* LocationalEvent::mutable_begin_analog_audio() {
  if (!has_begin_analog_audio()) {
    clear_events();
    set_has_begin_analog_audio();
    events_.begin_analog_audio_ = new ::NullSpaceIPC::BeginAnalogAudio;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.LocationalEvent.begin_analog_audio)
  return events_.begin_analog_audio_;
}
inline ::NullSpaceIPC::BeginAnalogAudio* LocationalEvent::release_begin_analog_audio() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.LocationalEvent.begin_analog_audio)
  if (has_begin_analog_audio()) {
    clear_has_events();
    ::NullSpaceIPC::BeginAnalogAudio* temp = events_.begin_analog_audio_;
    events_.begin_analog_audio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocationalEvent::set_allocated_begin_analog_audio(::NullSpaceIPC::BeginAnalogAudio* begin_analog_audio) {
  clear_events();
  if (begin_analog_audio) {
    set_has_begin_analog_audio();
    events_.begin_analog_audio_ = begin_analog_audio;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.LocationalEvent.begin_analog_audio)
}

// optional .NullSpaceIPC.EndAnalogAudio end_analog_audio = 17;
inline bool LocationalEvent::has_end_analog_audio() const {
  return events_case() == kEndAnalogAudio;
}
inline void LocationalEvent::set_has_end_analog_audio() {
  _oneof_case_[0] = kEndAnalogAudio;
}
inline void LocationalEvent::clear_end_analog_audio() {
  if (has_end_analog_audio()) {
    delete events_.end_analog_audio_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::EndAnalogAudio& LocationalEvent::end_analog_audio() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.LocationalEvent.end_analog_audio)
  return has_end_analog_audio()
      ? *events_.end_analog_audio_
      : ::NullSpaceIPC::EndAnalogAudio::default_instance();
}
inline ::NullSpaceIPC::EndAnalogAudio* LocationalEvent::mutable_end_analog_audio() {
  if (!has_end_analog_audio()) {
    clear_events();
    set_has_end_analog_audio();
    events_.end_analog_audio_ = new ::NullSpaceIPC::EndAnalogAudio;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.LocationalEvent.end_analog_audio)
  return events_.end_analog_audio_;
}
inline ::NullSpaceIPC::EndAnalogAudio* LocationalEvent::release_end_analog_audio() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.LocationalEvent.end_analog_audio)
  if (has_end_analog_audio()) {
    clear_has_events();
    ::NullSpaceIPC::EndAnalogAudio* temp = events_.end_analog_audio_;
    events_.end_analog_audio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LocationalEvent::set_allocated_end_analog_audio(::NullSpaceIPC::EndAnalogAudio* end_analog_audio) {
  clear_events();
  if (end_analog_audio) {
    set_has_end_analog_audio();
    events_.end_analog_audio_ = end_analog_audio;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.LocationalEvent.end_analog_audio)
}

inline bool LocationalEvent::has_events() const {
  return events_case() != EVENTS_NOT_SET;
}
inline void LocationalEvent::clear_has_events() {
  _oneof_case_[0] = EVENTS_NOT_SET;
}
inline LocationalEvent::EventsCase LocationalEvent::events_case() const {
  return LocationalEvent::EventsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EnableTracking

// -------------------------------------------------------------------

// DisableTracking

// -------------------------------------------------------------------

// DeviceEvent

// optional uint32 device = 1;
inline void DeviceEvent::clear_device() {
  device_ = 0u;
}
inline ::google::protobuf::uint32 DeviceEvent::device() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.DeviceEvent.device)
  return device_;
}
inline void DeviceEvent::set_device(::google::protobuf::uint32 value) {
  
  device_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.DeviceEvent.device)
}

// optional .NullSpaceIPC.EnableTracking enable_tracking = 16;
inline bool DeviceEvent::has_enable_tracking() const {
  return events_case() == kEnableTracking;
}
inline void DeviceEvent::set_has_enable_tracking() {
  _oneof_case_[0] = kEnableTracking;
}
inline void DeviceEvent::clear_enable_tracking() {
  if (has_enable_tracking()) {
    delete events_.enable_tracking_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::EnableTracking& DeviceEvent::enable_tracking() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.DeviceEvent.enable_tracking)
  return has_enable_tracking()
      ? *events_.enable_tracking_
      : ::NullSpaceIPC::EnableTracking::default_instance();
}
inline ::NullSpaceIPC::EnableTracking* DeviceEvent::mutable_enable_tracking() {
  if (!has_enable_tracking()) {
    clear_events();
    set_has_enable_tracking();
    events_.enable_tracking_ = new ::NullSpaceIPC::EnableTracking;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.DeviceEvent.enable_tracking)
  return events_.enable_tracking_;
}
inline ::NullSpaceIPC::EnableTracking* DeviceEvent::release_enable_tracking() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.DeviceEvent.enable_tracking)
  if (has_enable_tracking()) {
    clear_has_events();
    ::NullSpaceIPC::EnableTracking* temp = events_.enable_tracking_;
    events_.enable_tracking_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DeviceEvent::set_allocated_enable_tracking(::NullSpaceIPC::EnableTracking* enable_tracking) {
  clear_events();
  if (enable_tracking) {
    set_has_enable_tracking();
    events_.enable_tracking_ = enable_tracking;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.DeviceEvent.enable_tracking)
}

// optional .NullSpaceIPC.DisableTracking disable_tracking = 17;
inline bool DeviceEvent::has_disable_tracking() const {
  return events_case() == kDisableTracking;
}
inline void DeviceEvent::set_has_disable_tracking() {
  _oneof_case_[0] = kDisableTracking;
}
inline void DeviceEvent::clear_disable_tracking() {
  if (has_disable_tracking()) {
    delete events_.disable_tracking_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::DisableTracking& DeviceEvent::disable_tracking() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.DeviceEvent.disable_tracking)
  return has_disable_tracking()
      ? *events_.disable_tracking_
      : ::NullSpaceIPC::DisableTracking::default_instance();
}
inline ::NullSpaceIPC::DisableTracking* DeviceEvent::mutable_disable_tracking() {
  if (!has_disable_tracking()) {
    clear_events();
    set_has_disable_tracking();
    events_.disable_tracking_ = new ::NullSpaceIPC::DisableTracking;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.DeviceEvent.disable_tracking)
  return events_.disable_tracking_;
}
inline ::NullSpaceIPC::DisableTracking* DeviceEvent::release_disable_tracking() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.DeviceEvent.disable_tracking)
  if (has_disable_tracking()) {
    clear_has_events();
    ::NullSpaceIPC::DisableTracking* temp = events_.disable_tracking_;
    events_.disable_tracking_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DeviceEvent::set_allocated_disable_tracking(::NullSpaceIPC::DisableTracking* disable_tracking) {
  clear_events();
  if (disable_tracking) {
    set_has_disable_tracking();
    events_.disable_tracking_ = disable_tracking;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.DeviceEvent.disable_tracking)
}

inline bool DeviceEvent::has_events() const {
  return events_case() != EVENTS_NOT_SET;
}
inline void DeviceEvent::clear_has_events() {
  _oneof_case_[0] = EVENTS_NOT_SET;
}
inline DeviceEvent::EventsCase DeviceEvent::events_case() const {
  return DeviceEvent::EventsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HighLevelEvent

// optional uint64 parent_id = 1;
inline void HighLevelEvent::clear_parent_id() {
  parent_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HighLevelEvent::parent_id() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.parent_id)
  return parent_id_;
}
inline void HighLevelEvent::set_parent_id(::google::protobuf::uint64 value) {
  
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.HighLevelEvent.parent_id)
}

// optional .NullSpaceIPC.PlaybackEvent playback_event = 2;
inline bool HighLevelEvent::has_playback_event() const {
  return events_case() == kPlaybackEvent;
}
inline void HighLevelEvent::set_has_playback_event() {
  _oneof_case_[0] = kPlaybackEvent;
}
inline void HighLevelEvent::clear_playback_event() {
  if (has_playback_event()) {
    delete events_.playback_event_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::PlaybackEvent& HighLevelEvent::playback_event() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.playback_event)
  return has_playback_event()
      ? *events_.playback_event_
      : ::NullSpaceIPC::PlaybackEvent::default_instance();
}
inline ::NullSpaceIPC::PlaybackEvent* HighLevelEvent::mutable_playback_event() {
  if (!has_playback_event()) {
    clear_events();
    set_has_playback_event();
    events_.playback_event_ = new ::NullSpaceIPC::PlaybackEvent;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.playback_event)
  return events_.playback_event_;
}
inline ::NullSpaceIPC::PlaybackEvent* HighLevelEvent::release_playback_event() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.playback_event)
  if (has_playback_event()) {
    clear_has_events();
    ::NullSpaceIPC::PlaybackEvent* temp = events_.playback_event_;
    events_.playback_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_playback_event(::NullSpaceIPC::PlaybackEvent* playback_event) {
  clear_events();
  if (playback_event) {
    set_has_playback_event();
    events_.playback_event_ = playback_event;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.playback_event)
}

// optional .NullSpaceIPC.LocationalEvent locational_event = 3;
inline bool HighLevelEvent::has_locational_event() const {
  return events_case() == kLocationalEvent;
}
inline void HighLevelEvent::set_has_locational_event() {
  _oneof_case_[0] = kLocationalEvent;
}
inline void HighLevelEvent::clear_locational_event() {
  if (has_locational_event()) {
    delete events_.locational_event_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::LocationalEvent& HighLevelEvent::locational_event() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.locational_event)
  return has_locational_event()
      ? *events_.locational_event_
      : ::NullSpaceIPC::LocationalEvent::default_instance();
}
inline ::NullSpaceIPC::LocationalEvent* HighLevelEvent::mutable_locational_event() {
  if (!has_locational_event()) {
    clear_events();
    set_has_locational_event();
    events_.locational_event_ = new ::NullSpaceIPC::LocationalEvent;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.locational_event)
  return events_.locational_event_;
}
inline ::NullSpaceIPC::LocationalEvent* HighLevelEvent::release_locational_event() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.locational_event)
  if (has_locational_event()) {
    clear_has_events();
    ::NullSpaceIPC::LocationalEvent* temp = events_.locational_event_;
    events_.locational_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_locational_event(::NullSpaceIPC::LocationalEvent* locational_event) {
  clear_events();
  if (locational_event) {
    set_has_locational_event();
    events_.locational_event_ = locational_event;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.locational_event)
}

// optional .NullSpaceIPC.DeviceEvent device_event = 4;
inline bool HighLevelEvent::has_device_event() const {
  return events_case() == kDeviceEvent;
}
inline void HighLevelEvent::set_has_device_event() {
  _oneof_case_[0] = kDeviceEvent;
}
inline void HighLevelEvent::clear_device_event() {
  if (has_device_event()) {
    delete events_.device_event_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::DeviceEvent& HighLevelEvent::device_event() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.device_event)
  return has_device_event()
      ? *events_.device_event_
      : ::NullSpaceIPC::DeviceEvent::default_instance();
}
inline ::NullSpaceIPC::DeviceEvent* HighLevelEvent::mutable_device_event() {
  if (!has_device_event()) {
    clear_events();
    set_has_device_event();
    events_.device_event_ = new ::NullSpaceIPC::DeviceEvent;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.device_event)
  return events_.device_event_;
}
inline ::NullSpaceIPC::DeviceEvent* HighLevelEvent::release_device_event() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.device_event)
  if (has_device_event()) {
    clear_has_events();
    ::NullSpaceIPC::DeviceEvent* temp = events_.device_event_;
    events_.device_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_device_event(::NullSpaceIPC::DeviceEvent* device_event) {
  clear_events();
  if (device_event) {
    set_has_device_event();
    events_.device_event_ = device_event;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.device_event)
}

// optional .NullSpaceIPC.ClientIdentificationEvent client_id_event = 16;
inline bool HighLevelEvent::has_client_id_event() const {
  return events_case() == kClientIdEvent;
}
inline void HighLevelEvent::set_has_client_id_event() {
  _oneof_case_[0] = kClientIdEvent;
}
inline void HighLevelEvent::clear_client_id_event() {
  if (has_client_id_event()) {
    delete events_.client_id_event_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::ClientIdentificationEvent& HighLevelEvent::client_id_event() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.client_id_event)
  return has_client_id_event()
      ? *events_.client_id_event_
      : ::NullSpaceIPC::ClientIdentificationEvent::default_instance();
}
inline ::NullSpaceIPC::ClientIdentificationEvent* HighLevelEvent::mutable_client_id_event() {
  if (!has_client_id_event()) {
    clear_events();
    set_has_client_id_event();
    events_.client_id_event_ = new ::NullSpaceIPC::ClientIdentificationEvent;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.client_id_event)
  return events_.client_id_event_;
}
inline ::NullSpaceIPC::ClientIdentificationEvent* HighLevelEvent::release_client_id_event() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.client_id_event)
  if (has_client_id_event()) {
    clear_has_events();
    ::NullSpaceIPC::ClientIdentificationEvent* temp = events_.client_id_event_;
    events_.client_id_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_client_id_event(::NullSpaceIPC::ClientIdentificationEvent* client_id_event) {
  clear_events();
  if (client_id_event) {
    set_has_client_id_event();
    events_.client_id_event_ = client_id_event;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.client_id_event)
}

inline bool HighLevelEvent::has_events() const {
  return events_case() != EVENTS_NOT_SET;
}
inline void HighLevelEvent::clear_has_events() {
  _oneof_case_[0] = EVENTS_NOT_SET;
}
inline HighLevelEvent::EventsCase HighLevelEvent::events_case() const {
  return HighLevelEvent::EventsCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NullSpaceIPC

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NullSpaceIPC::PlaybackEvent_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NullSpaceIPC::PlaybackEvent_Command>() {
  return ::NullSpaceIPC::PlaybackEvent_Command_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HighLevelEvent_2eproto__INCLUDED
